<!DOCTYPE html>
<html class="client-nojs" lang="en-CA" dir="ltr">

<!-- Mirrored from docs.derivative.ca/Write_a_GLSL_Material by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 24 May 2025 00:55:07 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>Write a GLSL Material - Derivative</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"21e043df979b94887a3569ff","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Write_a_GLSL_Material","wgTitle":"Write a GLSL Material","wgCurRevisionId":33289,"wgRevisionId":33289,"wgArticleId":1484,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Touch Glossary","Rendering","TDPages","TouchDesigner Tips","Materials","GLSL","Programming in TouchDesigner"],"wgPageContentLanguage":"en-ca","wgPageContentModel":"wikitext","wgRelevantPageName":"Write_a_GLSL_Material","wgRelevantArticleId":1484,"wgIsProbablyEditable":false,
"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgCargoDefaultQueryLimit":100,"wgCargoMapClusteringMinimum":80,"wgCargoMonthNames":["January","February","March","April","May","June","July","August","September","October","November","December"],"wgCargoMonthNamesShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgCargoWeekDays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"wgCargoWeekDaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"wgPageFormsTargetName":null,"wgPageFormsAutocompleteValues":[],"wgPageFormsAutocompleteOnAllChars":false,"wgPageFormsFieldProperties":[],"wgPageFormsCargoFields":[],"wgPageFormsDependentFields":[],"wgPageFormsCalendarValues":[],"wgPageFormsCalendarParams":[],"wgPageFormsCalendarHTML":null,"wgPageFormsGridValues":[],"wgPageFormsGridParams":[],"wgPageFormsContLangYes":null,"wgPageFormsContLangNo":null,"wgPageFormsContLangMonths":[],
"wgPageFormsHeightForMinimizingInstances":800,"wgPageFormsShowOnSelect":[],"wgPageFormsScriptPath":"/extensions/PageForms","edgValues":[],"wgPageFormsEDSettings":null,"wgAmericanDates":false,"wgVector2022PreviewPages":[]};RLSTATE={"site.styles":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","ext.Lingo.styles":"ready","skins.vector.styles.legacy":"ready"};RLPAGEMODULES=["ext.UiTag","ext.Lingo","site","mediawiki.page.ready","mediawiki.toc","skins.vector.legacy.js"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="load6e85.css?lang=en-ca&amp;modules=ext.Lingo.styles%7Cext.pygments%7Cskins.vector.styles.legacy&amp;only=styles&amp;skin=vector"/>
<script async="" src="load4355.php?lang=en-ca&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="load7c2b.css?lang=en-ca&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.39.0"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="twitter:card" content="summary_large_image"/>
<meta name="viewport" content="width=1000"/>
<link rel="icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="Derivative (en-ca)"/>
<link rel="EditURI" type="application/rsd+xml" href="api-result251f.xml?action=rsd"/>
<link rel="alternate" type="application/atom+xml" title="Derivative Atom feed" href="https://docs.derivative.ca/index.php?title=Special:RecentChanges&amp;feed=atom"/>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-3123499-6"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-3123499-6');
</script>
<meta property="og:title" content="Write a GLSL Material"/>
<meta property="og:site_name" content="Derivative"/>
<meta property="og:url" content="https://docs.derivative.ca/Write_a_GLSL_Material"/>
<meta property="og:image" content="https://docs.derivative.ca/resources/assets/logo.png"/>
<meta property="article:modified_time" content="2025-04-09T03:51:27Z"/>
<meta property="article:published_time" content="2025-04-09T03:51:27Z"/>
<script type="application/ld+json">{"@context":"http:\/\/schema.org","@type":"Article","name":"Write a GLSL Material - Derivative","headline":"Write a GLSL Material - Derivative","mainEntityOfPage":"<span class=\"mw-page-title-main\">Write a GLSL Material<\/span>","identifier":"https:\/\/docs.derivative.ca\/Write_a_GLSL_Material","url":"https:\/\/docs.derivative.ca\/Write_a_GLSL_Material","dateModified":"2025-04-09T03:51:27Z","datePublished":"2025-04-09T03:51:27Z","image":{"@type":"ImageObject","url":"https:\/\/docs.derivative.ca\/resources\/assets\/logo.png"},"author":{"@type":"Organization","name":"Derivative","url":"https:\/\/docs.derivative.ca","logo":{"@type":"ImageObject","url":"https:\/\/docs.derivative.ca\/resources\/assets\/logo.png","caption":"Derivative"}},"publisher":{"@type":"Organization","name":"Derivative","url":"https:\/\/docs.derivative.ca","logo":{"@type":"ImageObject","url":"https:\/\/docs.derivative.ca\/resources\/assets\/logo.png","caption":"Derivative"}},"potentialAction":{"@type":"SearchAction","target":"https:\/\/docs.derivative.ca\/index.php?title=Special:Search&search={search_term}","query-input":"required name=search_term"}}</script>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Write_a_GLSL_Material rootpage-Write_a_GLSL_Material skin-vector action-view skin-vector-legacy vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-language-alert-in-sidebar-disabled vector-feature-sticky-header-disabled vector-feature-sticky-header-edit-disabled vector-feature-table-of-contents-disabled vector-feature-visual-enhancement-next-disabled"><div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice"></div>
	<div class="mw-indicators">
	</div>
	<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Write a GLSL Material</span></h1>
	<div id="bodyContent" class="vector-body">
		<div id="siteSub" class="noprint">From Derivative</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en-CA" dir="ltr"><div class="mw-parser-output"><div class="mw-parser-output"><div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en-CA" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul><li class="toclevel-1 tocsection-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a>
<ul><li class="toclevel-2 tocsection-2"><a href="#GLSL_Version"><span class="tocnumber">1.1</span> <span class="toctext">GLSL Version</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#The_concept_of_GLSL_Shaders"><span class="tocnumber">1.2</span> <span class="toctext">The concept of GLSL Shaders</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#TouchDesigner_GLSL_conventions"><span class="tocnumber">1.3</span> <span class="toctext">TouchDesigner GLSL conventions</span></a></li>
</ul></li>
<li class="toclevel-1 tocsection-5"><a href="#Shader_Stages"><span class="tocnumber">2</span> <span class="toctext">Shader Stages</span></a>
<ul><li class="toclevel-2 tocsection-6"><a href="#Vertex_Shader"><span class="tocnumber">2.1</span> <span class="toctext">Vertex Shader</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Pixel_Shader"><span class="tocnumber">2.2</span> <span class="toctext">Pixel Shader</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Geometry_Shader"><span class="tocnumber">2.3</span> <span class="toctext">Geometry Shader</span></a></li>
</ul></li>
<li class="toclevel-1 tocsection-9"><a href="#A_Basic_Shader"><span class="tocnumber">3</span> <span class="toctext">A Basic Shader</span></a>
<ul><li class="toclevel-2 tocsection-10"><a href="#Vertex_Shader_2"><span class="tocnumber">3.1</span> <span class="toctext">Vertex Shader</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Pixel_Shader_2"><span class="tocnumber">3.2</span> <span class="toctext">Pixel Shader</span></a></li>
</ul></li>
<li class="toclevel-1 tocsection-12"><a href="#Working_with_Geometry_Attributes"><span class="tocnumber">4</span> <span class="toctext">Working with Geometry Attributes</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#TouchDesigner_specific_defines"><span class="tocnumber">5</span> <span class="toctext">TouchDesigner specific defines</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#TouchDesigner_specific_Uniforms"><span class="tocnumber">6</span> <span class="toctext">TouchDesigner specific Uniforms</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#TouchDesigner_specific_Functions"><span class="tocnumber">7</span> <span class="toctext">TouchDesigner specific Functions</span></a>
<ul><li class="toclevel-2 tocsection-16"><a href="#Vertex_Shader_Only_Functions"><span class="tocnumber">7.1</span> <span class="toctext">Vertex Shader Only Functions</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Geometry_Shader_Only_Functions"><span class="tocnumber">7.2</span> <span class="toctext">Geometry Shader Only Functions</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Pixel_Shader_Only_Functions"><span class="tocnumber">7.3</span> <span class="toctext">Pixel Shader Only Functions</span></a>
<ul><li class="toclevel-3 tocsection-19"><a href="#Physically_Based_(PBR)_Lighting"><span class="tocnumber">7.3.1</span> <span class="toctext">Physically Based (PBR) Lighting</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Phong_Lighting"><span class="tocnumber">7.3.2</span> <span class="toctext">Phong Lighting</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="#Common_Lighting_Functions"><span class="tocnumber">7.3.3</span> <span class="toctext">Common Lighting Functions</span></a></li>
</ul></li>
<li class="toclevel-2 tocsection-22"><a href="#Common_Functions"><span class="tocnumber">7.4</span> <span class="toctext">Common Functions</span></a>
<ul><li class="toclevel-3 tocsection-23"><a href="#General_functions"><span class="tocnumber">7.4.1</span> <span class="toctext">General functions</span></a></li>
<li class="toclevel-3 tocsection-24"><a href="#Matrix_functions"><span class="tocnumber">7.4.2</span> <span class="toctext">Matrix functions</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="#Perlin_and_Simplex_noise_functions"><span class="tocnumber">7.4.3</span> <span class="toctext">Perlin and Simplex noise functions</span></a></li>
<li class="toclevel-3 tocsection-26"><a href="#HSV_Conversion"><span class="tocnumber">7.4.4</span> <span class="toctext">HSV Conversion</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="#Projection_Conversions"><span class="tocnumber">7.4.5</span> <span class="toctext">Projection Conversions</span></a></li>
</ul></li>
</ul></li>
<li class="toclevel-1 tocsection-28"><a href="#Working_with_Lights"><span class="tocnumber">8</span> <span class="toctext">Working with Lights</span></a>
<ul><li class="toclevel-2 tocsection-29"><a href="#Custom_work_with_lights"><span class="tocnumber">8.1</span> <span class="toctext">Custom work with lights</span></a>
<ul><li class="toclevel-3 tocsection-30"><a href="#Knowing_which_variables_correspond_to_which_Light_COMPs"><span class="tocnumber">8.1.1</span> <span class="toctext">Knowing which variables correspond to which Light COMPs</span></a></li>
<li class="toclevel-3 tocsection-31"><a href="#Light_Parameters"><span class="tocnumber">8.1.2</span> <span class="toctext">Light Parameters</span></a></li>
<li class="toclevel-3 tocsection-32"><a href="#Cone_Lighting_Technique"><span class="tocnumber">8.1.3</span> <span class="toctext">Cone Lighting Technique</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#Attenuation"><span class="tocnumber">8.1.4</span> <span class="toctext">Attenuation</span></a></li>
<li class="toclevel-3 tocsection-34"><a href="#Projection_and_Shadow_Mapping"><span class="tocnumber">8.1.5</span> <span class="toctext">Projection and Shadow Mapping</span></a>
<ul><li class="toclevel-4 tocsection-35"><a href="#Projection_Mapping"><span class="tocnumber">8.1.5.1</span> <span class="toctext">Projection Mapping</span></a></li>
<li class="toclevel-4 tocsection-36"><a href="#Shadow_Mapping"><span class="tocnumber">8.1.5.2</span> <span class="toctext">Shadow Mapping</span></a></li>
</ul></li>
</ul></li>
</ul></li>
<li class="toclevel-1 tocsection-37"><a href="#Multiple_Render_Targets"><span class="tocnumber">9</span> <span class="toctext">Multiple Render Targets</span></a></li>
<li class="toclevel-1 tocsection-38"><a href="#Multi-Camera_Rendering"><span class="tocnumber">10</span> <span class="toctext">Multi-Camera Rendering</span></a></li>
<li class="toclevel-1 tocsection-39"><a href="#Image_Outputs"><span class="tocnumber">11</span> <span class="toctext">Image Outputs</span></a></li>
<li class="toclevel-1 tocsection-40"><a href="#Outputting_gl_Position"><span class="tocnumber">12</span> <span class="toctext">Outputting gl_Position</span></a></li>
<li class="toclevel-1 tocsection-41"><a href="#Specilization_Constants"><span class="tocnumber">13</span> <span class="toctext">Specilization Constants</span></a></li>
<li class="toclevel-1 tocsection-42"><a href="#Working_with_Deforms"><span class="tocnumber">14</span> <span class="toctext">Working with Deforms</span></a>
<ul><li class="toclevel-2 tocsection-43"><a href="#Skinning_Deforms_(Bone_Deforms)"><span class="tocnumber">14.1</span> <span class="toctext">Skinning Deforms (Bone Deforms)</span></a>
<ul><li class="toclevel-3 tocsection-44"><a href="#Functions"><span class="tocnumber">14.1.1</span> <span class="toctext">Functions</span></a></li>
</ul></li>
<li class="toclevel-2 tocsection-45"><a href="#Instancing"><span class="tocnumber">14.2</span> <span class="toctext">Instancing</span></a>
<ul><li class="toclevel-3 tocsection-46"><a href="#Instance_Index/ID"><span class="tocnumber">14.2.1</span> <span class="toctext">Instance Index/ID</span></a></li>
<li class="toclevel-3 tocsection-47"><a href="#Deform_Functions"><span class="tocnumber">14.2.2</span> <span class="toctext">Deform Functions</span></a></li>
<li class="toclevel-3 tocsection-48"><a href="#Attribute_Functions"><span class="tocnumber">14.2.3</span> <span class="toctext">Attribute Functions</span></a></li>
<li class="toclevel-3 tocsection-49"><a href="#Instance_Texturing"><span class="tocnumber">14.2.4</span> <span class="toctext">Instance Texturing</span></a></li>
</ul></li>
</ul></li>
<li class="toclevel-1 tocsection-50"><a href="#Point_Sprites"><span class="tocnumber">15</span> <span class="toctext">Point Sprites</span></a></li>
<li class="toclevel-1 tocsection-51"><a href="#Order_Independent_Transparency"><span class="tocnumber">16</span> <span class="toctext">Order Independent Transparency</span></a></li>
<li class="toclevel-1 tocsection-52"><a href="#Dithering"><span class="tocnumber">17</span> <span class="toctext">Dithering</span></a></li>
<li class="toclevel-1 tocsection-53"><a href="#Picking"><span class="tocnumber">18</span> <span class="toctext">Picking</span></a></li>
<li class="toclevel-1 tocsection-54"><a href="#Shadertoy"><span class="tocnumber">19</span> <span class="toctext">Shadertoy</span></a>
<ul><li class="toclevel-2 tocsection-55"><a href="#VR_Shaders"><span class="tocnumber">19.1</span> <span class="toctext">VR Shaders</span></a></li>
</ul></li>
<li class="toclevel-1 tocsection-56"><a href="#Other_Notes"><span class="tocnumber">20</span> <span class="toctext">Other Notes</span></a>
<ul><li class="toclevel-2 tocsection-57"><a href="##version_statement"><span class="tocnumber">20.1</span> <span class="toctext">#version statement</span></a></li>
<li class="toclevel-2 tocsection-58"><a href="##include_statements"><span class="tocnumber">20.2</span> <span class="toctext">#include statements</span></a></li>
<li class="toclevel-2 tocsection-59"><a href="#Diagnosing_crashes_due_to_GLSL"><span class="tocnumber">20.3</span> <span class="toctext">Diagnosing crashes due to GLSL</span></a></li>
<li class="toclevel-2 tocsection-60"><a href="#Changes_from_GLSL_1.20"><span class="tocnumber">20.4</span> <span class="toctext">Changes from GLSL 1.20</span></a></li>
<li class="toclevel-2 tocsection-61"><a href="#Major_changes_since_TouchDesigner088"><span class="tocnumber">20.5</span> <span class="toctext">Major changes since TouchDesigner088</span></a></li>
</ul></li>
<li class="toclevel-1 tocsection-62"><a href="#Related_Articles"><span class="tocnumber">21</span> <span class="toctext">Related Articles</span></a></li>
</ul></div>

<h2><span class="mw-headline" id="Overview">Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=1" title="Edit section: Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This document explains the finer points of writing a GLSL <span class="mw-lingo-term" data-lingo-term-id="d92a8333dd3ccb895cc65f7455b71206">Material</span> in TouchDesigner. It is assumed the reader already has an understanding of the GLSL language. The official GLSL documentation can be found at <a rel="nofollow" class="external text" href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)">this address.</a>
</p>
<h3><span class="mw-headline" id="GLSL_Version">GLSL Version</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=2" title="Edit section: GLSL Version">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>TouchDesigner uses GLSL 3.30 and newer versions as it's language. Many online examples, as well as WebGL shaders, are written against GLSL 1.20. There are some significant language differences between GLSL 1.20 and GLSL 3.30+. For information about some of these differences, please refer to <a href="#Changes_from_GLSL_1.20">Changes from GLSL 1.20</a>
</p>
<h3><span class="mw-headline" id="The_concept_of_GLSL_Shaders">The concept of GLSL Shaders</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=3" title="Edit section: The concept of GLSL Shaders">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A GLSL <a href="Shader.html" title="Shader">Shader</a> is a program that is applied to geometry as it is being rendered. A GLSL shader is split into two main components, vertex shader and pixel shader.
</p><p><b><span class="mw-lingo-term" data-lingo-term-id="b22b929ba52471a02d18bb3a4e4472e6">Vertex</span> <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span></b> - A vertex shader is a program that is applied to every vertex of the geometry the <span class="mw-lingo-term" data-lingo-term-id="d92a8333dd3ccb895cc65f7455b71206">Material</span> is applied to.
</p><p><b>Pixel <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span></b> - A pixel shader is a program that is applied to every pixel that is drawn. This is often also referred to as a Fragment <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span>.
</p><p>There is also the <b>Geometry <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span></b>, which is a stage between the vertex and pixel stages, but it isn't used very often. For more information on Geometry Shaders have a look <a rel="nofollow" class="external text" href="https://open.gl/geometry">here</a>.
</p>
<h3><span class="mw-headline" id="TouchDesigner_GLSL_conventions">TouchDesigner GLSL conventions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=4" title="Edit section: TouchDesigner GLSL conventions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>All functions and uniforms provided by TouchDesigner as augmentations of the GLSL language will follow these conventions.
</p>
<ul><li>Function names will always start with the letters <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">TD</span><span class="w"></span></code>. e.g. <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">TDLighting</span><span class="p">()</span><span class="w"></span></code>.</li></ul><ul><li>Uniforms will start with the letters <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">uTD</span><span class="w"></span></code>.</li></ul><ul><li>Samplers will start with the letters <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">sTD</span><span class="w"></span></code>.</li></ul><ul><li>Images will start with the letters <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">mTD</span><span class="w"></span></code>.</li></ul><ul><li><span class="mw-lingo-term" data-lingo-term-id="b22b929ba52471a02d18bb3a4e4472e6">Vertex</span> input attributes will be named the same as they are in the TouchDesigner <span class="mw-lingo-term" data-lingo-term-id="28a7e2d07553a70b039bb585895e0bf0">SOP</span> interface (P, N, uv).</li></ul><p>Most uniforms provided by TouchDesigner will be contained in Uniform Blocks. This means instead of accessing a single matrix by <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">uTDMatrixName</span><span class="w"></span></code>, the matrices will be stored a single block with many matrices such as <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">uTDMats</span><span class="w"></span></code>, which has members such as <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">uTDMats</span><span class="p">[</span><span class="mo">0</span><span class="p">].</span><span class="n">worldCam</span><span class="w"></span></code> and <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">uTDMats</span><span class="p">[</span><span class="mo">0</span><span class="p">].</span><span class="n">projInverse</span><span class="w"></span></code>.
</p>
<h2><span class="mw-headline" id="Shader_Stages"><span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span> Stages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=5" title="Edit section: Shader Stages">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Vertex_Shader"><span class="mw-lingo-term" data-lingo-term-id="b22b929ba52471a02d18bb3a4e4472e6">Vertex</span> <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=6" title="Edit section: Vertex Shader">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Inside a vertex shader you only have access to one vertex, you don't know the positions of other vertices are or what the output of the vertex shader for other vertices will be. 
</p><p>The input to a vertex shader is all the data about the particular vertex that the program is running on. Data like the vertex position in <span class="mw-lingo-term" data-lingo-term-id="28a7e2d07553a70b039bb585895e0bf0">SOP</span> space, texture coordinate, color, normal are available. These values are called attributes. <span class="mw-lingo-term" data-lingo-term-id="287234a1ff35a314b5b6bc4e5828e745">Attributes</span> are declared in the vertex shader using the <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="k">in</span><span class="w"></span></code> keyword.
</p><p>The vertex shader can output many things. The primary things it will output are the vertex position (after being transformed by the world, camera and projection matrix), color, and texture coordinates. It can output any other values as well using output variables declared using <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="k">out</span><span class="w"></span></code>. Outputs from a vertex shader are linearly interpolated across the surface of the primitive the vertex is a part of. For example, if you output a value of 0.2 at 1st vertex and a value of 0.4 at the 2nd vertex on a line, a pixel drawn half-way between these two points will receive a value of 0.3.
</p>
<h3><span class="mw-headline" id="Pixel_Shader">Pixel <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=7" title="Edit section: Pixel Shader">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The inputs to a pixel shader are all of the outputs from the vertex shader, and any uniforms that are defined. The outputs from the vertex shader will have been linearly interpolated across the polygon that the vertices created. A pixel shader can output two things: Color and Depth. Color is output through the variable declared as <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">whateverName</span><span class="w"></span></code>. Depth is output through a variable declared as <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="k">out</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">depthName</span><span class="w"></span></code>. You can name these variables whatever you want. You are required to write out a color value, but you do not need to write out depth (in fact it's best if you don't unless absolutely needed). GLSL will automatically output the correct depth value for you if you don't write out a depth value. If you are outputting to multiple color buffer, you declare more color outputs with the <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">location</span><span class="w"></span></code> value set to 1, 2, 3, etc., instead of 0.
</p>
<h3><span class="mw-headline" id="Geometry_Shader">Geometry <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=8" title="Edit section: Geometry Shader">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A geometry shader takes a single point primitive points, line or triangle, and outputs set of points, line strips, or triangle strips. Currently in TouchDesigner the input primitive types you must use to match with what we are rendering is one of:
</p>
<pre> layout(points) in;
 layout(lines_adjacency) in;
 layout(triangles) in;
</pre>
<p>Other input types such as <code>lines</code> or <code>triangles_adjacency</code> is not currently supported.
</p><p><b>Note</b> - In the 2018.20000 series of builds <code>lines</code> were supported and <code>lines_adjacency</code> were not, so the change to the 2019.10000 that switched the support to <code>lines_adjacency</code> unfortunetely breaks existing geometry shaders.
</p>
<h2><span class="mw-headline" id="A_Basic_Shader">A Basic <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=9" title="Edit section: A Basic Shader">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Vertex_Shader_2"><span class="mw-lingo-term" data-lingo-term-id="b22b929ba52471a02d18bb3a4e4472e6">Vertex</span> <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=10" title="Edit section: Vertex Shader">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This vertex shader will simply transform each vertex correctly and leave it entirely up to the pixel shader to color the pixels:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// P is the position of the current vertex</span><span class="w"></span>
<span class="w">	</span><span class="c1">// TDDeform() will return the deformed P position, in world space.</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Transform it from world space to projection space so it can be rasterized</span><span class="w"></span>
<span class="w">	</span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TDWorldToProj</span><span class="p">(</span><span class="n">TDDeform</span><span class="p">(</span><span class="n">TDPos</span><span class="p">()));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Pixel_Shader_2">Pixel <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=11" title="Edit section: Pixel Shader">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This pixel shader simply sets every pixel to red:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// We need to declare the name of the output fragment color (this is different from GLSL 1.2 where it was automatically declared as gl_FragColor)</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">fragColor</span><span class="p">;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">fragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mo">0</span><span class="p">,</span><span class="w"> </span><span class="mo">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Working_with_Geometry_Attributes">Working with Geometry <span class="mw-lingo-term" data-lingo-term-id="287234a1ff35a314b5b6bc4e5828e745">Attributes</span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=12" title="Edit section: Working with Geometry Attributes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The follow vertex shader attributes (inputs) will always be declared for you to use in your vertex shader. You do not need to declare them yourself.
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">vec3</span><span class="w"> </span><span class="n">TDPos</span><span class="p">();</span><span class="w"> </span><span class="c1">// <span class="mw-lingo-term" data-lingo-term-id="b22b929ba52471a02d18bb3a4e4472e6">Vertex</span> position</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDNormal</span><span class="p">();</span><span class="w"> </span><span class="c1">// normal</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDTexCoord</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="n">coordLayer</span><span class="p">);</span><span class="w"> </span><span class="c1">// texture coordinate layers</span><span class="w"></span>
</pre></div>
<p><b>Other <span class="mw-lingo-term" data-lingo-term-id="287234a1ff35a314b5b6bc4e5828e745">Attributes</span></b>
</p><p>All other attributes you want to use need to be declared in your shader code. are passed as custom attributes. For forward compatibility with POPs in the future, these attributes should be declared using the '<span class="mw-lingo-term" data-lingo-term-id="287234a1ff35a314b5b6bc4e5828e745">Attributes</span>' page on the GLSL <span class="mw-lingo-term" data-lingo-term-id="f0c2c0ca864067cc6e21a7ea2c1b1fdd">MAT</span>. The declared attributes can be accessed via a function call to <code>TDAttrib_&lt;attributeName&gt;()</code>.
For example if you declare a custom attribute called 'life'. You would access it in the shader using <code>TDAttrib_life()</code>.
</p>
<h2><span class="mw-headline" id="TouchDesigner_specific_defines">TouchDesigner specific defines</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=13" title="Edit section: TouchDesigner specific defines">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Shaders in TouchDesigner are dynamically recompiled based on a few things such as the number and types of lights in the scene or the number of cameras used in this pass (in the case of <a href="#Multi-Camera_Rendering">Multi-Camera Rendering</a>). This is done for optimization purposes since loops with known amounts of iterations are far faster in GLSL. Some defines are provided which allow code written by end-users to be recompiled with different numbers of lights/cameras correct. 
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// This define will be defined at compile time, and your shader will be recompiled for each combination</span><span class="w"></span>
<span class="c1">// of lights in use (if it's is used in multiple light configurations). You can use it for things like a loop</span><span class="w"></span>
<span class="c1">// counter to loop over all lights in the scene, as you will see if you output example code from the Phong <span class="mw-lingo-term" data-lingo-term-id="f0c2c0ca864067cc6e21a7ea2c1b1fdd">MAT</span>.</span><span class="w"></span>
<span class="c1">// Environment COMPs are counted separately from regular Light COMPs.</span><span class="w"></span>
<span class="cp">#define TD_NUM_LIGHTS &lt;defined at compile time&gt;</span><span class="w"></span>
<span class="cp">#define TD_NUM_ENV_LIGHTS &lt;defined at compile time&gt;</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// On newer hardware multiple cameras can be rendered at the same time. This define will be set to the</span><span class="w"></span>
<span class="c1">// number of cameras done on this render pass. This may be 1 or more, depending on many factors.</span><span class="w"></span>
<span class="c1">// Code should be written in a way that should work regardless of what this value is.</span><span class="w"></span>
<span class="cp">#define TD_NUM_CAMERAS &lt;defined at compiler time&gt;</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// One of these defines will be set depending on which shader stage is being compiled.</span><span class="w"></span>
<span class="c1">// This allows shaders to use #ifdef &lt;stageName&gt; and #ifndef &lt;stageName&gt; to either include or</span><span class="w"></span>
<span class="c1">// omit code based on the current shader stage being included. This also allows for single</span><span class="w"></span>
<span class="c1">// large DATs to contain all the code for all stages, with each portion #ifdef-ed in for</span><span class="w"></span>
<span class="c1">// each stage.</span><span class="w"></span>
<span class="cp">#define TD_VERTEX_SHADER</span><span class="w"></span>
<span class="cp">#define TD_GEOMETRY_SHADER</span><span class="w"></span>
<span class="cp">#define TD_PIXEL_SHADER</span><span class="w"></span>
<span class="cp">#define TD_COMPUTE_SHADER</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="TouchDesigner_specific_Uniforms">TouchDesigner specific Uniforms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=14" title="Edit section: TouchDesigner specific Uniforms">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>These are uniform that TouchDesigner will automatically set for you. You do not need to declare any of these, you can just use them in your shaders.
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// General rendering state info</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">TDGeneral</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">vec4</span><span class="w"> </span><span class="n">ambientColor</span><span class="p">;</span><span class="w">  </span><span class="c1">// Ambient light color (sum of all Ambient Light COMPs used)</span><span class="w"></span>
<span class="w">  </span><span class="kt">vec4</span><span class="w"> </span><span class="n">viewport</span><span class="p">;</span><span class="w">      </span><span class="c1">// viewport info, contains (x, y, 1.0 / w, 1.0 / h). x/y/w/h are in pixel units.   </span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">uniform</span><span class="w"> </span><span class="n">TDGeneral</span><span class="w"> </span><span class="n">uTDGeneral</span><span class="p">;</span><span class="w"></span>
<span class="c1">// So for example you'd get the ambient color by doing </span><span class="w"></span>
<span class="c1">// vec4 ambientColor = uTDGeneral.ambientColor;</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Matrices</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">TDMatrix</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">world</span><span class="p">;</span><span class="w">			</span><span class="c1">// world transform matrix, combination of hierarchy of Object COMPs containing the <span class="mw-lingo-term" data-lingo-term-id="28a7e2d07553a70b039bb585895e0bf0">SOP</span>.</span><span class="w"></span>
<span class="w">						</span><span class="c1">// transforms from <span class="mw-lingo-term" data-lingo-term-id="28a7e2d07553a70b039bb585895e0bf0">SOP</span> space into World Space</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">worldInverse</span><span class="p">;</span><span class="w">	</span><span class="c1">// inverse of the world matrix</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">worldCam</span><span class="p">;</span><span class="w">		</span><span class="c1">// multiplication of the world and the camera matrix. (Cam * World)</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">worldCamInverse</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">cam</span><span class="p">;</span><span class="w">			</span><span class="c1">// camera transform matrix, obtained from the Camera <span class="mw-lingo-term" data-lingo-term-id="85a1cdddc59cb89e6297acc2f2fc1755">COMP</span> used to render</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">camInverse</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">camProj</span><span class="p">;</span><span class="w">		</span><span class="c1">// camera transform and the projection matrix from the camera <span class="mw-lingo-term" data-lingo-term-id="85a1cdddc59cb89e6297acc2f2fc1755">COMP</span>, (Proj * Cam)</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">camProjInverse</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">proj</span><span class="p">;</span><span class="w">			</span><span class="c1">// projection matrix from the Camera <span class="mw-lingo-term" data-lingo-term-id="85a1cdddc59cb89e6297acc2f2fc1755">COMP</span>. The Z range will be [0,1], Vulkan style.</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">projInverse</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">worldCamProj</span><span class="p">;</span><span class="w">	</span><span class="c1">// multiplication of the world, camera and projection matrices. (Proj * Cam * World)</span><span class="w"></span>
<span class="w">						</span><span class="c1">// takes a vertex in <span class="mw-lingo-term" data-lingo-term-id="28a7e2d07553a70b039bb585895e0bf0">SOP</span> space and puts it into projection space</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">worldCamProjInverse</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat3</span><span class="w"> </span><span class="n">worldForNormals</span><span class="p">;</span><span class="w">	</span><span class="c1">// Inverse transpose of the world matrix, use this to transform normals</span><span class="w"></span>
<span class="w">							</span><span class="c1">// from <span class="mw-lingo-term" data-lingo-term-id="28a7e2d07553a70b039bb585895e0bf0">SOP</span> space into world space</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat3</span><span class="w"> </span><span class="n">camForNormals</span><span class="p">;</span><span class="w">		</span><span class="c1">// Inverse transpose of the camera matrix, use this to transform normals</span><span class="w"></span>
<span class="w">							</span><span class="c1">// from world space into camera space</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat3</span><span class="w"> </span><span class="n">worldCamForNormals</span><span class="p">;</span><span class="w">	</span><span class="c1">// Inverse transpose of the worldCam matrix, use this to transform normals</span><span class="w"></span>
<span class="w">								</span><span class="c1">// from <span class="mw-lingo-term" data-lingo-term-id="28a7e2d07553a70b039bb585895e0bf0">SOP</span> space into camera space inverse(transpose(Cam * World))</span><span class="w"></span>
<span class="w">	   </span>
<span class="p">};</span><span class="w"></span>
<span class="k">uniform</span><span class="w"> </span><span class="n">TDMatrix</span><span class="w"> </span><span class="n">uTDMats</span><span class="p">[</span><span class="n">TD_NUM_CAMERAS</span><span class="p">];</span><span class="w"></span>
<span class="c1">// For example you'd transform the vertex in <span class="mw-lingo-term" data-lingo-term-id="28a7e2d07553a70b039bb585895e0bf0">SOP</span> space into camera space with this line of code</span><span class="w"></span>
<span class="c1">// vec4 camSpaceVert = uTDMats[TDCameraIndex()].worldCam * vec4(TDPos(), 1.0);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="n">TDCameraInfo</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec4</span><span class="w"> </span><span class="n">nearFar</span><span class="p">;</span><span class="w">			</span><span class="c1">// near/far plane info, contains (near, far, far - near, 1.0 / (far - near))</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec4</span><span class="w"> </span><span class="n">fog</span><span class="p">;</span><span class="w">				</span><span class="c1">// fog info, as defined in the Camera <span class="mw-lingo-term" data-lingo-term-id="85a1cdddc59cb89e6297acc2f2fc1755">COMP</span></span><span class="w"></span>
<span class="w">							</span><span class="c1">// contains (fogStart, fogEnd, 1.0 / (fogEnd - fogStart), fogDensity)</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec4</span><span class="w"> </span><span class="n">fogColor</span><span class="p">;</span><span class="w">			</span><span class="c1">// Fog Color as defined in the Camera <span class="mw-lingo-term" data-lingo-term-id="85a1cdddc59cb89e6297acc2f2fc1755">COMP</span></span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">renderTOPCameraIndex</span><span class="p">;</span><span class="w">	</span><span class="c1">// Says which camera from the Render <span class="mw-lingo-term" data-lingo-term-id="6705777b712ee811e76fb07162081d63">TOP</span>'s 'Cameras' parameter this particular camera is.</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">uniform</span><span class="w"> </span><span class="n">TDCameraInfo</span><span class="w"> </span><span class="n">uTDCamInfos</span><span class="p">[</span><span class="n">TD_NUM_CAMERAS</span><span class="p">];</span><span class="w"></span>
</pre></div>
<p>In general you don't need to do anything with any of these light uniforms/samplers, as it's all done for you in the <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">TDLighting</span><span class="p">(),</span><span class="w"> </span><span class="n">TDLightingPBR</span><span class="p">()</span><span class="w"> </span><span class="n">and</span><span class="p">,</span><span class="w"> </span><span class="n">TDEnvLightingPBR</span><span class="p">()</span><span class="w"></span></code> functions. Only if you are doing custom lighting will you need to worry about these.
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="n">TDLight</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec4</span><span class="w"> </span><span class="n">position</span><span class="p">;</span><span class="w">		</span><span class="c1">// the light's position in world space</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span><span class="w">		</span><span class="c1">// the light's direction in world space</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="p">;</span><span class="w">		</span><span class="c1">// the light's diffuse color</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec4</span><span class="w"> </span><span class="n">nearFar</span><span class="p">;</span><span class="w">		</span><span class="c1">// the near and far settings from the light's View page</span><span class="w"></span>
<span class="w">						</span><span class="c1">// contains (near, far, far - near, 1.0 / (far - near)</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec4</span><span class="w"> </span><span class="n">lightSize</span><span class="p">;</span><span class="w">		</span><span class="c1">// values from the light's Light Size parameter</span><span class="w"></span>
<span class="w">						</span><span class="c1">// containers (light width, light height, light width / light projection width, light height / light projection height)</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec4</span><span class="w"> </span><span class="n">misc</span><span class="p">;</span><span class="w">			</span><span class="c1">// misc parameters values, right now it contains</span><span class="w"></span>
<span class="w">						</span><span class="c1">// (Max shadow softness, 0, 0, 0)</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec4</span><span class="w"> </span><span class="n">coneLookupScaleBias</span><span class="p">;</span><span class="w">	</span><span class="c1">// applied to a cone light's contribution to create the spot lit area</span><span class="w"></span>
<span class="w">								</span><span class="c1">// contains (coneLookupScale, coneLookupBias, 1.0, 0.0).</span><span class="w"></span>
<span class="w">                                </span><span class="c1">// If the light is not a cone light, this will contain (0.0, 0.0, 0.0, 0.0).</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec4</span><span class="w"> </span><span class="n">attenScaleBiasRoll</span><span class="p">;</span><span class="w">	</span><span class="c1">// applied to the light's distance from the point to get an attenuation value</span><span class="w"></span>
<span class="w">								</span><span class="c1">// contains (attenuation scale, attenuation bias, attenuation rolloff, 0)</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">shadowMapMatrix</span><span class="p">;</span><span class="w">		</span><span class="c1">// transforms a point in world space into the projection space of the shadow mapped light</span><span class="w"></span>
<span class="w">								</span><span class="c1">// also rescales projection space from [-1, 1] to [0, 1], so the value can be used</span><span class="w"></span>
<span class="w">								</span><span class="c1">// to lookup into a shadow map</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">shadowMapCamMatrix</span><span class="p">;</span><span class="w">	</span><span class="c1">// transforms a point in world space into the camera space of the shadow mapped light</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec4</span><span class="w"> </span><span class="n">shadowMapRes</span><span class="p">;</span><span class="w">			</span><span class="c1">// the resolution of the shadow map associated with this light</span><span class="w"></span>
<span class="w">								</span><span class="c1">// contains (1.0 / width, 1.0 / height, width, height)</span><span class="w"></span>
<span class="w">								</span><span class="c1">// filled with 0s if the light isn't shadow mapped</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat4</span><span class="w"> </span><span class="n">projMapMatrix</span><span class="p">;</span><span class="w">			</span><span class="c1">// transforms a point in world space into the projection map space of the light</span><span class="w"></span>
<span class="w">								</span><span class="c1">// used when using textureProj() function for projection mapping</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span>
<span class="k">uniform</span><span class="w"> </span><span class="n">TDLight</span><span class="w"> </span><span class="n">uTDLights</span><span class="p">[</span><span class="n">TD_NUM_LIGHTS</span><span class="p">];</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="n">TDEnvLight</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w">					</span><span class="c1">// Color of the env light (not counting it's environment map)</span><span class="w"></span>
<span class="w">	</span><span class="kt">mat3</span><span class="w"> </span><span class="n">rotate</span><span class="p">;</span><span class="w">				</span><span class="c1">// Rotation to be applied to the env light.</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">uniform</span><span class="w"> </span><span class="n">TDEnvLight</span><span class="w"> </span><span class="n">uTDEnvLights</span><span class="p">[</span><span class="n">TD_NUM_ENV_LIGHTS</span><span class="p">];</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// This one is held differently since it's backed by a storage buffer object and not a uniform buffer object.</span><span class="w"></span>
<span class="k">buffer</span><span class="w"> </span><span class="n">TDEnvLightBuffer</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">shCoeffs</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span><span class="w"> </span><span class="c1">// Spherical harmonic coefficients calculated from the environment map. Used for diffuse PBR lighting.</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">uTDEnvLightBuffers</span><span class="p">[</span><span class="n">TD_ENV_LIGHTS_ARRAY_SIZE</span><span class="p">];</span><span class="w"></span>
</pre></div>
<p>When using sampler3D created using a <a href="Texture_3D_TOP.html" title="Texture 3D TOP">Texture 3D TOP</a>, it can sometimes be useful to know which slice is the 'newest' slice in the array, when using the <a href="Texture_3D_TOP.html" title="Texture 3D TOP">Texture 3D TOP</a> as a circular cache. The P-coordinate location of where the newest slice will provided by a uniform named the same as your sampler, with the suffix 'POffset'. For example if you have a uniform named sColorMap, you can declare a matching <code>sColorMapPOffset</code> uniform and it will automatically be filled in for you.
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">sColorMapPOffset</span><span class="p">;</span><span class="w"> </span><span class="c1">// P offset to newest slice in sampler3D named sColorMap</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="TouchDesigner_specific_Functions">TouchDesigner specific Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=15" title="Edit section: TouchDesigner specific Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Further details about each of these functions are given in the sections following this.
</p>
<h3><span class="mw-headline" id="Vertex_Shader_Only_Functions"><span class="mw-lingo-term" data-lingo-term-id="b22b929ba52471a02d18bb3a4e4472e6">Vertex</span> <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span> Only Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=16" title="Edit section: Vertex Shader Only Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Transforms a point from world space to projection space. </span><span class="w"></span>
<span class="c1">// These functions should always be used to output to gl_Position, allowing TouchDesigner to do custom manipulations</span><span class="w"></span>
<span class="c1">// of the values as needed for special operations and projections.</span><span class="w"></span>
<span class="c1">// The extra manipulations that are currently done are:</span><span class="w"></span>
<span class="c1">// 1. Conversions to other projections such as FishEye</span><span class="w"></span>
<span class="c1">// 2. Conversions to <span class="mw-lingo-term" data-lingo-term-id="f38ba60f185531947a20345d16feda13">Quad Reprojection</span> using TDQuadReproject()</span><span class="w"></span>
<span class="c1">// 3. Adjustments needed for picking using TDPickAdjust().</span><span class="w"></span>
<span class="c1">// When using this function you should not call the above functions, since it will do those for you.</span><span class="w"></span>
<span class="c1">// Both the vec4 and vec3 version of TDWorldToProj() treat the xyz as a point, not a vector.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDWorldToProj</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDWorldToProj</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>


<span class="c1">// These ones take an extra 'uv' coordinate, which is used when UV Unwrapping is done in the Render <span class="mw-lingo-term" data-lingo-term-id="6705777b712ee811e76fb07162081d63">TOP</span>.</span><span class="w"></span>
<span class="c1">// If the version without the uv is used, then TDInstanceTexCoord(TDUVUnwrapCoord()) will be used to get the texture coord.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDWorldToProj</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">uv</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDWorldToProj</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">uv</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Returns the color for this vertex/point, including handling alpha-premultiplication correctly.</span><span class="w"></span>
<span class="c1">// This replaces accessing it directly via 'Cd', as was done in the past.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDPointColor</span><span class="p">();</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Returns the instance ID for the current instance. This should always be used, not gl_InstanceID directly.</span><span class="w"></span>
<span class="c1">// For more information look at the Instancing section of this document.</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">TDInstanceID</span><span class="p">();</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Returns the index of the camera for this particular vertex, within this batch. Needed to support Multi-Camera <span class="mw-lingo-term" data-lingo-term-id="a6e8f9aed2ac6481dc25a18a33342d03">Rendering</span>.</span><span class="w"></span>
<span class="c1">// This is always 0-based, and it does not reflect which camera is being currently being used from the Render <span class="mw-lingo-term" data-lingo-term-id="6705777b712ee811e76fb07162081d63">TOP</span>.</span><span class="w"></span>
<span class="c1">// Due to multiple batches being needed for split up larger amounts of cameras, this number resets to be 0 each batch.</span><span class="w"></span>
<span class="c1">// To get the actual camera index as it's listed in the Render <span class="mw-lingo-term" data-lingo-term-id="6705777b712ee811e76fb07162081d63">TOP</span>, use the uTDCamInfos[TDCameraIndex()].renderTOPCameraIndex</span><span class="w"></span>
<span class="c1">// or, in builds 2022.32790 and later TDTrueCameraIndex().</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">TDCameraIndex</span><span class="p">();</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Available in builds 2022.32790 and later.</span><span class="w"></span>
<span class="c1">// Returns the index of the camera as it's listed in the Render <span class="mw-lingo-term" data-lingo-term-id="6705777b712ee811e76fb07162081d63">TOP</span>.</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">TDTrueCameraIndex</span><span class="p">();</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Deforms a point or vector using instancing and skinned deforms. The returned result is in World Space.</span><span class="w"></span>
<span class="c1">// Be sure to use the *Vec version in the case of vectors to get correct results.</span><span class="w"></span>
<span class="c1">// Also use the *Norm version when deforming a normal, to make sure it still matches the surface correctly.</span><span class="w"></span>
<span class="c1">/// These functions will internally call TDSkinnedDeform() and TDInstanceDeform().</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDDeform</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDDeform</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDDeformVec</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDDeformNorm</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// These versions allow you to control the instanceID used for the deform.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDDeform</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceID</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDDeformVec</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceID</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDDeformNorm</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceID</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// ** In general you don't need to call any of the below functions, just calling TDDeform or TDDeformVec will</span><span class="w"></span>
<span class="c1">// do all the work for you</span><span class="w"></span>
<span class="c1">// Just the skinning or instancing portion of the deforms</span><span class="w"></span>
<span class="c1">// Returned position/vector is in <span class="mw-lingo-term" data-lingo-term-id="28a7e2d07553a70b039bb585895e0bf0">SOP</span> space for the *Skinned* version, and world space for the *<span class="mw-lingo-term" data-lingo-term-id="d9a17c1c9e8ef6866e4dbeef41c741b2">Instance</span>* version.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDSkinnedDeform</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDSkinnedDeformVec</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">vec</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceDeform</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDInstanceDeformVec</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">vec</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// You also don't need to call these usually, but are available for special cases</span><span class="w"></span>
<span class="c1">// For instancing functions, if you don't provide an index, it will use TDInstanceID().</span><span class="w"></span>
<span class="kt">mat4</span><span class="w"> </span><span class="n">TDBoneMat</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">boneIndex</span><span class="p">);</span><span class="w"></span>
<span class="kt">mat4</span><span class="w"> </span><span class="n">TDInstanceMat</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceID</span><span class="p">);</span><span class="w"></span>
<span class="kt">mat4</span><span class="w"> </span><span class="n">TDInstanceMat</span><span class="p">();</span><span class="w"></span>
<span class="c1">// Returns a 3x3 matrix only. Useful if you are only working with vectors, not positions.</span><span class="w"></span>
<span class="c1">// If you are using both, it is faster to just call TDInstanceMat(), and cast the result to a mat3</span><span class="w"></span>
<span class="c1">// when required.</span><span class="w"></span>
<span class="kt">mat3</span><span class="w"> </span><span class="n">TDInstanceMat3</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceID</span><span class="p">);</span><span class="w"></span>
<span class="kt">mat3</span><span class="w"> </span><span class="n">TDInstanceMat3</span><span class="p">();</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// To calculate the texture coordinates for your instance (if used in the Geometry <span class="mw-lingo-term" data-lingo-term-id="85a1cdddc59cb89e6297acc2f2fc1755">COMP</span>'s parameters), use these functions</span><span class="w"></span>
<span class="c1">// For texture coordinates the passed in variable 't' is the current texture coordinate to be modified/replaced</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDInstanceTexCoord</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceID</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDInstanceTexCoord</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// TDWorldToProj() will already apply the Quad Reproject feature if used by the [[Camera <span class="mw-lingo-term" data-lingo-term-id="85a1cdddc59cb89e6297acc2f2fc1755">COMP</span>]].</span><span class="w"></span>
<span class="c1">// However in same cases you may be doing custom operations that require it to be applied manually.</span><span class="w"></span>
<span class="c1">// This function just returns the point unchanged if Quad Reproject isn't being used.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDQuadReproject</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">camIndex</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Available in builds 2019.32020 or later.</span><span class="w"></span>
<span class="c1">// TDWorldToProj() will already apply the Picking adjustment if required (when picking is occuring).</span><span class="w"></span>
<span class="c1">// However in same cases you may be doing custom operations that require it to be applied manually.</span><span class="w"></span>
<span class="c1">// This function should be given the position after it's been transformed into projection space.</span><span class="w"></span>
<span class="c1">// This function just returns the point unchanged if picking isn't active for this render.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDPickAdjust</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">camIndex</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p><br></p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Returns the uv coordinate that was selected for UV unwrapping in the Render <span class="mw-lingo-term" data-lingo-term-id="6705777b712ee811e76fb07162081d63">TOP</span></span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDUVUnwrapCoord</span><span class="p">();</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Geometry_Shader_Only_Functions">Geometry <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span> Only Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=17" title="Edit section: Geometry Shader Only Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Similar to th ones in the vertex shader, but require a camera index since it</span><span class="w"></span>
<span class="c1">// needs to be passed through to the geometry shader via a input variable.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDWorldToProj</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cameraIndex</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="err">"</span><span class="p">;</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDWorldToProj</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cameraIndex</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="err">"</span><span class="p">;</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDWorldToProj</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cameraIndex</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="err">"</span><span class="p">;</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDWorldToProj</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cameraIndex</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="err">"</span><span class="p">;</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDQuadReproject</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">camIndex</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Pixel_Shader_Only_Functions">Pixel <span class="mw-lingo-term" data-lingo-term-id="a88a92f4a0e793589f2341851a15c660">Shader</span> Only Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=18" title="Edit section: Pixel Shader Only Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// This function is provided as a wrapper for gl_FrontFacing.</span><span class="w"></span>
<span class="c1">// It is required since some GPUs (Intel on macOS mainly) have broken</span><span class="w"></span>
<span class="c1">// functionality for gl_FrontFacing.</span><span class="w"></span>
<span class="c1">// On most GPUs this just returns gl_FrontFacing. On GPUs where the behavior</span><span class="w"></span>
<span class="c1">// is broken, an alternative method using position and normal is used to </span><span class="w"></span>
<span class="c1">// determine if the pixel is front or back facing.</span><span class="w"></span>
<span class="c1">// Position and normal should be in the same space, and normal must be normalized.</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">TDFrontFacing</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Call this function to give TouchDesigner a chance to discard some pixels if appropriate.</span><span class="w"></span>
<span class="c1">// This is used in things such as order-indepdendent transparency and dual-paraboloid rendering.</span><span class="w"></span>
<span class="c1">// For best performance call it at the start of the pixel shader.</span><span class="w"></span>
<span class="c1">// It will do nothing if no features that require it are active, so it's safe to always call it.</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">TDCheckDiscard</span><span class="p">();</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Obtain the texture coordinate for point sprite primitives.</span><span class="w"></span>
<span class="c1">// This must be used instead of gl_PointCoord, otherwise the coordinates may be flipped vertically</span><span class="w"></span>
<span class="c1">// in some cases.</span><span class="w"></span>
<span class="kt">vec2</span><span class="w"> </span><span class="n">TDPointCoord</span><span class="p">();</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Obtain the modified color for this pixel. Pass in the interpolated point color from the vertex shader.</span><span class="w"></span>
<span class="c1">// This function usually just returns back the passed argument, but when doing Geo Text <span class="mw-lingo-term" data-lingo-term-id="85a1cdddc59cb89e6297acc2f2fc1755">COMP</span> rendering,</span><span class="w"></span>
<span class="c1">// it is needed to create the text glyphs.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDPixelColor</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Call this function to apply the alpha test to the current pixel. This function will do nothing</span><span class="w"></span>
<span class="c1">// if the alpha test is disabled, so it can be safely always called</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">TDAlphaTest</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">alphaValue</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Call this to apply the Camera COMPs fog to the passed color. Requires the world space vertex position also</span><span class="w"></span>
<span class="c1">// This function will do nothing if fog is disabled, so it's safe to always call it at the end of your shader</span><span class="w"></span>
<span class="c1">// there would be no performance impact from calling it if fog is disabled</span><span class="w"></span>
<span class="c1">// the cameraIndex should be passed through from the vertex shader using a varying, sourced from TDCameraIndex()</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDFog</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">curColor</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpacePos</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cameraIndex</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Call this at the end of your shadow to apply a dither to your final color. This function does nothing</span><span class="w"></span>
<span class="c1">// if dithering is disabled in the Render TOPs parameters</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDDither</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">curColor</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Pass any color value through this function before writing it out to a color buffer.</span><span class="w"></span>
<span class="c1">// This is needed to ensure that color channels are output to the correct channels</span><span class="w"></span>
<span class="c1">// in the color buffer, based on hardware limitation that may store alpha-only</span><span class="w"></span>
<span class="c1">// textures as red-only internally, for example</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDOutputSwizzle</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">curColor</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>The TDLighting() functions are called per light to determine that light's diffuse and specular contributions.
Shadowing, projection mapping are all automatically handled for you inside this functions.
</p>
<ul><li>The <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">TDPBRResult</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">TDPhongResult</span><span class="w"></span></code> return structure will be filled with the results.</li>
<li><code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">lightIndex</span><span class="w"></span></code> is the light index to calculate</li>
<li><code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">worldSpacePos</span><span class="w"></span></code> is the world space vertex position</li>
<li><code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">shadowStrength</span><span class="w"></span></code> is a scalar on the shadow to increase or decrease its effect for example a value of 0.5 would give a maximum 50% shadow.</li>
<li><code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">shadowColor</span><span class="w"></span></code> is a vec3 for the color to shift to when something is shadowed. Usually this is vec3(0).</li>
<li><code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">worldSpaceNorm</span><span class="w"></span></code> is the normalized world space normal</li>
<li><code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">vertToCamVec</span><span class="w"></span></code> is the normalized vector from the vertex position to the camera position.</li>
<li><code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">shininess</span><span class="w"></span></code> is the specular shininess exponent.</li></ul><h4><span id="Physically_Based_.28PBR.29_Lighting"></span><span class="mw-headline" id="Physically_Based_(PBR)_Lighting">Physically Based (PBR) Lighting</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=19" title="Edit section: Physically Based (PBR) Lighting">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Will be filled with the results of the lighting calculations</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">TDPBRResult</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Contains how much the pixel is inside a shadow for this light. 0 means no shadow, 1 means fully shadowed.</span><span class="w"></span>
<span class="w">	</span><span class="kt">float</span><span class="w"> </span><span class="n">shadowStrength</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// For all regular lights. Should be called in a loop from 0 to TD_NUM_LIGHTS</span><span class="w"></span>
<span class="n">TDPBRResult</span><span class="w"> </span><span class="n">TDLightingPBR</span><span class="p">(</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">diffuseColor</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">specularColor</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpacePos</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpaceNormal</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">float</span><span class="w"> </span><span class="n">shadowStrength</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">shadowColor</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">vertToCamVec</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">float</span><span class="w"> </span><span class="n">roughness</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// For environment lights. Should be called in a loop from 0 to TD_NUM_ENV_LIGHTS</span><span class="w"></span>
<span class="n">TDPBRResult</span><span class="w"> </span><span class="n">TDEnvLightingPBR</span><span class="p">(</span><span class="w"></span>
<span class="w">	</span><span class="k">inout</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">diffuseContrib</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="k">inout</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">specularContrib</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">diffuseColor</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">specularColor</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpaceNormal</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">vertToCamVec</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">float</span><span class="w"> </span><span class="n">roughness</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">float</span><span class="w"> </span><span class="n">ambientOcclusion</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Phong_Lighting">Phong Lighting</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=20" title="Edit section: Phong Lighting">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Will be filled with the results of the lighting calculations</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">TDPhongResult</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">specular2</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Contains how much the pixel is inside a shadow for this light. 0 means no shadow, 1 means fully shadowed.</span><span class="w"></span>
<span class="w">    </span><span class="c1">// This is already accounted for in the returned diffuse/specular colors, but is returned here as extra</span><span class="w"></span>
<span class="w">    </span><span class="c1">// meta-information which can be used for other </span><span class="w"></span>
<span class="w">	</span><span class="kt">float</span><span class="w"> </span><span class="n">shadowStrength</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="n">TDPhongResult</span><span class="w"> </span><span class="n">TDLighting</span><span class="p">(</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpacePos</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpaceNorm</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">float</span><span class="w"> </span><span class="n">shadowStrength</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">shadowColor</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">vertToCamVec</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">float</span><span class="w"> </span><span class="n">shininess</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="kt">float</span><span class="w"> </span><span class="n">shininess2</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Common_Lighting_Functions">Common Lighting Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=21" title="Edit section: Common Lighting Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// In general you don't need to use these functions, they are called for you in the TDLighting() functions.</span><span class="w"></span>
<span class="c1">// These functions return the shadow strength at the current pixel for light at the given index.</span><span class="w"></span>
<span class="c1">// Also requires the world space vertex position to do its calculations</span><span class="w"></span>
<span class="c1">// returns undefined results if the shadow isn't mapped using the chosen shadow type</span><span class="w"></span>
<span class="c1">// The returned value is 0 for no shadow, 1 for 100% shadowed</span><span class="w"></span>
<span class="c1">// Due to percentage closer filtering, hard shadows can still have values between 0 and 1 at the edges of the shadow</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDHardShadow</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpacePos</span><span class="p">);</span><span class="w"></span>
<span class="c1">// This one will apply soft shadows with both 25 search steps done, and 25 filter samples.</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDSoftShadow</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpacePos</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Allows for control of search steps and filter samples.</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDSoftShadow</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpacePos</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">samples</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">searchSteps</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Gets the projection map color for the given world space vertex position.</span><span class="w"></span>
<span class="c1">// No other lighting calculations are applied to the returned color</span><span class="w"></span>
<span class="c1">// If the given light index is not using a projection map, then 'defaultColor' is returned.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDProjMap</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpacePosition</span><span class="p">,</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">defaultColor</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Directly access environment maps for the env lights. Will be black for lights that don't have a map</span><span class="w"></span>
<span class="c1">// of that particular dimensionality.</span><span class="w"></span>
<span class="c1">// For the 2D map based env lights.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDEnvLightTextureLod</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">coord</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">mipLevel</span><span class="p">);</span><span class="w"></span>
<span class="c1">// For the Cube map based env lights.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDEnvLightTextureLod</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">coord</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">mipLevel</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// For directly accessing the shadow maps. All of these access the same maps (per index), but are setup in compare or sampling mode.</span><span class="w"></span>
<span class="c1">// A returned value of 1 means it's fully in the shadow, 0 means it's not in the shadow.</span><span class="w"></span>
<span class="c1">// For lights indices that aren't generating shadows, these functions will return 0.</span><span class="w"></span>
<span class="c1">// These two first one is used in the function texture(sampler2DShadow, vec3) or textureProj(sampler2DShadow, vec4)</span><span class="w"></span>
<span class="c1">// for automatic depth comparison and hardware percentage closer filtering.</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDCompareShadowTexture</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">coord</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">depth</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDCompareShadowTextureProj</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">coord</span><span class="p">);</span><span class="w"></span>

<span class="c1">// These ones is used for directly getting the depth from the shadow map using</span><span class="w"></span>
<span class="c1">// texture(sampler2D, vec2) or textureProj(sampler2D, vec3).</span><span class="w"></span>
<span class="c1">// If using hard shadows the values are in [0, 1] post-projection depth units.</span><span class="w"></span>
<span class="c1">// If using soft shadows the values are in camera space of the light (not the camera being rendered from).</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDShadowTexture</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">coord</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDShadowTextureProj</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">coord</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// The projection maps defined in the Projection Map parameter of the Light <span class="mw-lingo-term" data-lingo-term-id="85a1cdddc59cb89e6297acc2f2fc1755">COMP</span>.</span><span class="w"></span>
<span class="c1">// The map will return black if the light doesn't have a projection map defined.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDProjTexture</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">coord</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">mipMapBias</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Samples the texture using the same rules as textureProj().</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDProjTextureProj</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">coord</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// The falloff ramp from when the cone light starts to fade out until it reaches black.</span><span class="w"></span>
<span class="c1">// Used in combination with uTDLights[].coneLookupScaleBias.</span><span class="w"></span>
<span class="c1">// Will return 1.0 when the light is not a cone light.</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDConeLookup</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">coord</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Common_Functions">Common Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=22" title="Edit section: Common Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Available in all shader stages.
</p>
<h4><span class="mw-headline" id="General_functions">General functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=23" title="Edit section: General functions">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// A function that gives a half-sine ramp from 0 to 1.</span><span class="w"></span>
<span class="c1">// Sampling it with a coordinate outside the (0, 1) range will return 0 for anything below 0 and 1 for anything above 1.</span><span class="w"></span>
<span class="c1">// It's possibly faster than using the GLSL sin() function, depending on the hardware.</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDSineLookup</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">coord</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Matrix_functions">Matrix functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=24" title="Edit section: Matrix functions">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Creates a translation matrix for the given 3 translation values.</span><span class="w"></span>
<span class="kt">mat4</span><span class="w"> </span><span class="n">TDTranslate</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Creates a rotation matrix that rotates around the +X, +Y and +Z axis repectively.</span><span class="w"></span>
<span class="kt">mat3</span><span class="w"> </span><span class="n">TDRotateX</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">radians</span><span class="p">);</span><span class="w"></span>
<span class="kt">mat3</span><span class="w"> </span><span class="n">TDRotateY</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">radians</span><span class="p">);</span><span class="w"></span>
<span class="kt">mat3</span><span class="w"> </span><span class="n">TDRotateZ</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">radians</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Creates a rotation matrix that rotates around the 'axis', the given number of 'radians'</span><span class="w"></span>
<span class="c1">// The 'axis' vector must already be normalized before being passed to this function.</span><span class="w"></span>
<span class="kt">mat3</span><span class="w"> </span><span class="n">TDRotateOnAxis</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">radians</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">axis</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Creates a scale matrix for the given 3 scale values.</span><span class="w"></span>
<span class="kt">mat3</span><span class="w"> </span><span class="n">TDScale</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Creates a rotation matrix that rotates starting from looking down +Z, to the 'forward' vector direction.</span><span class="w"></span>
<span class="c1">// The 'forward' and 'up' vectors passed to this function do not need to be normalized.</span><span class="w"></span>
<span class="kt">mat3</span><span class="w"> </span><span class="n">TDRotateToVector</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">forward</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">up</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Creates a rotation matrix to rotate from vector 'from' to vector 'to'. The solution isn't particularly stable, but useful in some cases.</span><span class="w"></span>
<span class="c1">// The 'from' and 'to' vectors must already be normalized before being passed to this function.</span><span class="w"></span>
<span class="kt">mat3</span><span class="w"> </span><span class="n">TDCreateRotMatrix</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">to</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Takes a surface normal, the tangent to the surface, and a handedness value (either -1 or 1)</span><span class="w"></span>
<span class="c1">// Returns a matrix that will convert vectors from tangent space, to the space the normal and tangent are in</span><span class="w"></span>
<span class="c1">// Both the normal and the tangent must be normalized before this function is called.</span><span class="w"></span>
<span class="c1">// The w coordinate of the T attribute created by the [[Attribute Create <span class="mw-lingo-term" data-lingo-term-id="28a7e2d07553a70b039bb585895e0bf0">SOP</span>]] contains the handedness</span><span class="w"></span>
<span class="c1">// that should be passed in as-is.</span><span class="w"></span>
<span class="kt">mat3</span><span class="w"> </span><span class="n">TDCreateTBNMatrix</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">tangent</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">handedness</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Perlin_and_Simplex_noise_functions">Perlin and Simplex noise functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=25" title="Edit section: Perlin and Simplex noise functions">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Noise functions</span><span class="w"></span>
<span class="c1">// These will return the same result for the same input</span><span class="w"></span>
<span class="c1">// Results are between -1 and 1</span><span class="w"></span>
<span class="c1">// Can be slow so just be aware when using them. </span><span class="w"></span>
<span class="c1">// Different dimensionality selected by passing vec2, vec3 or vec4. </span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDPerlinNoise</span><span class="p">(</span><span class="kt">vec2</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDPerlinNoise</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDPerlinNoise</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDSimplexNoise</span><span class="p">(</span><span class="kt">vec2</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDSimplexNoise</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDSimplexNoise</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="HSV_Conversion">HSV Conversion</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=26" title="Edit section: HSV Conversion">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Converts between RGB and HSV color space</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDHSVToRGB</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDRGBToHSV</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Projection_Conversions">Projection Conversions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=27" title="Edit section: Projection Conversions">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Converts a 0-1 equirectangular texture coordinate into cubemap coordinates.</span><span class="w"></span>
<span class="c1">// A 0 for the U coordinate corresponds to the middle of the +X face. So along the vec3(1, Y, 0) plane.</span><span class="w"></span>
<span class="c1">// As U rises, equirectangular coordinates rotate from +X, to +Z, then -X and -Z.</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDEquirectangularToCubeMap</span><span class="p">(</span><span class="kt">vec2</span><span class="w"> </span><span class="n">equiCoord</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Converts from cubemap coordinates to equirectangular</span><span class="w"></span>
<span class="c1">// cubemapCoord MUST be normalized before calling this function.</span><span class="w"></span>
<span class="kt">vec2</span><span class="w"> </span><span class="n">TDCubeMapToEquirectangular</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">cubemapCoord</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Available in builds 2019.18140</span><span class="w"></span>
<span class="c1">// This version will also output a mipmap bias float. This float should be passed in the 'bias'</span><span class="w"></span>
<span class="c1">// parameter of texture(), to help select the mipmap level. This helps avoids seams at the edge</span><span class="w"></span>
<span class="c1">// of equirectangular map.</span><span class="w"></span>
<span class="kt">vec2</span><span class="w"> </span><span class="n">TDCubeMapToEquirectangular</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">cubemapCoord</span><span class="p">,</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">mipMapBias</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Working_with_Lights">Working with Lights</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=28" title="Edit section: Working with Lights">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To help shaders be as fast as possible, a lot of the logic to calculate lights is hard-coded into the shader depending on what features are enabled and what the light type is. Shaders written for the GLSL <span class="mw-lingo-term" data-lingo-term-id="f0c2c0ca864067cc6e21a7ea2c1b1fdd">MAT</span> will be recompiled with different implementation of TDLightingPBR(), TDLighting() etc depending on the number and types of lights in the scene. This allows the same GLSL <span class="mw-lingo-term" data-lingo-term-id="f0c2c0ca864067cc6e21a7ea2c1b1fdd">MAT</span> to be used in multiple different scenes without needing to be changed based on the number of lights in the scene. These compilations are cached, so each permutation of lighting settings will only cause one compilation to occur, each time TD is run.
</p><p><b>TIP:</b> Geometry viewers have built-in lighting separate from your scene's lighting objects. For information on how to duplicate that lighting, see the <a href="Geometry_Viewer.html" title="Geometry Viewer">Geometry Viewer</a> article.
</p>
<h3><span class="mw-headline" id="Custom_work_with_lights">Custom work with lights</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=29" title="Edit section: Custom work with lights">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If you decide to do custom lighting work, this section describes how a lot of the light values are used in our shader.
</p>
<h4><span class="mw-headline" id="Knowing_which_variables_correspond_to_which_Light_COMPs">Knowing which variables correspond to which Light COMPs</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=30" title="Edit section: Knowing which variables correspond to which Light COMPs">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The variables will be indexed to differentiate the lights, starting at 0. Light 0 will be the first light listed in the <a href="Render_TOP.html" title="Render TOP">Render TOP</a>, Light 1 will be the 2nd light listed and so on. In the event that lights are selected using a wildcard such as light*, the lights gathered from this wildcard will be sorted alpha-numerically.
</p><p>For example, say the <a href="Render_TOP.html" title="Render TOP">Render TOP</a> has "/light3 /container1/light* /alight1" listed in its Light parameter, and /container1/ has two light COMPs, named light1 and light2. In this case the lights would correspond to the following indices: <br>
/light3 would be index 0 <br>
/container1/light1 would be index 1 <br>
/container1/light2 would be index 2 <br>
/alight1 would be index 3
</p>
<h4><span class="mw-headline" id="Light_Parameters">Light Parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=31" title="Edit section: Light Parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>All of the parameters for the lights are defined in the uTDLights structure, defined <a href="Write_a_GLSL_Material.html#TouchDesigner_specific_Uniforms" title="Write a GLSL Material"> here</a>.
</p>
<h4><span class="mw-headline" id="Cone_Lighting_Technique">Cone Lighting Technique</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=32" title="Edit section: Cone Lighting Technique">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>TouchDesigner's built-in shaders use a custom cone-lighting technique that you can mimic in your shader. The intensity of the cone light is pre-computed into a 1D texture (a lookup table) to reduce the workload in the shader. The start of the 1D texture (texture coordinate 0.0) is the intensity of the light at the edge of the cone angle (the first pixel is always 0). The end of the 1D texture (texture coordinate 1.0) is the intensity of the light at the center of the cone. This lookup table is accessed via:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">TDConeLookup</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">coord</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>A second helper uniform is also given to the shader to make looking up in the 1D texture easier: 
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="n">uTDLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">coneLookupScaleBias</span><span class="p">;</span><span class="w"></span>
</pre></div>  
<p>To correctly look into this lookup table the following algorithm should be used:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// 'spot' is the spot vector</span><span class="w"></span>
<span class="c1">// 'lightV' is the vector coming from the light position, pointing towards</span><span class="w"></span>
<span class="c1">// the point on the geometry we are shading.</span><span class="w"></span>
<span class="c1">// It doesn't matter which space these vectors are in (camera space, object space), </span><span class="w"></span>
<span class="c1">// as long as they are both in the same space.</span><span class="w"></span>
<span class="c1">// Determine the cosine of the angle between the two vectors, will be between [-1, 1]</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">spotEffect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">spot</span><span class="p">,</span><span class="w"> </span><span class="n">lightV</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Now rescale the value using the special helper uniform so that value is between [0,1]</span><span class="w"></span>
<span class="c1">// A value of 0 will mean the angle between the two vectors is the same as the total </span><span class="w"></span>
<span class="c1">// cone angle + cone delta of the light</span><span class="w"></span>
<span class="n">spotEffect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">spotEffect</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">uTDLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">coneLookupScaleBias</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">uTDLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">coneLookupScaleBias</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Finally lookup into the lookup table</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">dimmer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TDConeLookup</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">spotEffect</span><span class="p">);</span><span class="w"></span>
<span class="c1">// You can now multiply the strength of the light by 'dimmer' to create the correct</span><span class="w"></span>
<span class="c1">// light intensity based on this pixels position in or outside the cone light's area of</span><span class="w"></span>
<span class="c1">// influence</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Attenuation">Attenuation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=33" title="Edit section: Attenuation">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Attenuation is handled for you in the TDLighting() function, but if you want to add it yourself this section describes how.
</p><p>To determine the attenuation from the light to a point in space, use this function. <code>lightDist</code> is the distance from the vertex to the light.
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Will return 1 if there is no attenuation, 0 if the light is fully attenuated, and something in between if it's in the fade-off region.</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">TDAttenuateLight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">lightDist</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>The math behind TDAttenutateLight is as follows:
</p><p>TouchDesigner's built-in shaders use a custom attenuation technique. Like the cone lighting, a pre-calculated scale and bias is provided for you that will allow you to get the correct attenuated intensity of the light. The uniform is: <br></p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="n">uTDLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">attenScaleBiasRoll</span><span class="w"> </span><span class="c1">// Contains (1 / -(attenEnd - attenStart), attenEnd / (attenEnd - attenStart), attenRolloff)</span><span class="w"></span>
</pre></div>
<p>TDAttenutateLight is defined as:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">TDAttenuateLight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lightIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">lightDist</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">lightAtten</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lightDist</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">uTDLights</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">attenScaleBiasRoll</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">lightAtten</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uTDLights</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">attenScaleBiasRoll</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">lightAtten</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clamp</span><span class="p">(</span><span class="n">lightAtten</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1.57073963</span><span class="w"></span>
<span class="w">    </span><span class="n">lightAtten</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">lightAtten</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">lightAtten</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">lightAtten</span><span class="p">,</span><span class="w"> </span><span class="n">uTDLights</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">attenScaleBiasRoll</span><span class="p">.</span><span class="n">z</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lightAtten</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Projection_and_Shadow_Mapping">Projection and Shadow Mapping</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=34" title="Edit section: Projection and Shadow Mapping">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Projection mapping and shadowing mapping are handled for you in the TDLighting() functions, but you can do it yourself if you want using the below information.
</p><p>Projection and Shadow mapping are very similar operations. The only difference is a projection map will be used to color the surface, while a shadow map will be used to decide if that surface receives lighting from a certain light.
</p>
<h5><span class="mw-headline" id="Projection_Mapping"><span class="mw-lingo-term" data-lingo-term-id="5213871d0c036a1f78c3c79db51d40d6">Projection Mapping</span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=35" title="Edit section: Projection Mapping">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>Use the <code>TDProjMap()</code> function, which will give you back the projection map color, including handling different projection types.
</p>
<h5><span class="mw-headline" id="Shadow_Mapping">Shadow Mapping</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=36" title="Edit section: Shadow Mapping">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>Use <code>TDHardShadow()</code> or <code>TDSoftShadow()</code> to manually get the shadow value.
</p>
<h2><span class="mw-headline" id="Multiple_Render_Targets">Multiple Render Targets</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=37" title="Edit section: Multiple Render Targets">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Using the '# Of Color Buffers' parameter in the <a href="Render_TOP.html" title="Render TOP">Render TOP</a> along with the <a href="Render_Select_TOP.html" title="Render Select TOP">Render Select TOP</a>, you can write GLSL shaders that output multiple color values per pixel. This is done by declaring and writing to pixel shader outputs declare like this:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">fragColor</span><span class="p">[</span><span class="n">TD_NUM_COLOR_BUFFERS</span><span class="p">];</span><span class="w"></span>
</pre></div>
<p>The constant TD_NUM_COLOR_BUFFERS with automatically be set for you based on the render settings. Ensure you are not writing beyond the number of buffers provided, or corruption/<span class="mw-lingo-term" data-lingo-term-id="52f9ec21735243ad9917cda3ca077d32">GPU</span> crashes may occur.
</p>
<h2><span class="mw-headline" id="Multi-Camera_Rendering">Multi-Camera <span class="mw-lingo-term" data-lingo-term-id="a6e8f9aed2ac6481dc25a18a33342d03">Rendering</span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=38" title="Edit section: Multi-Camera Rendering">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Multi-Camera <span class="mw-lingo-term" data-lingo-term-id="a6e8f9aed2ac6481dc25a18a33342d03">Rendering</span> is rendering multiple cameras in a single rendering pass, all looking at the same scene. This means the scene-graph is only traversed once, which avoids many calls to the graphics driver. Lights, textures, material and draw calls only need to be done once for the entire set of cameras being rendered. This feature is supported by Nvidia Pascal (Geforce 1000, Quadro P-Series) or AMD Polaris (Radeon R9, Radeon Pro WX) and newer GPUs. This feature is important for VR rendering, as well as things such as rendering a Cube Map in a single pass (instead of one pass per side).
</p><p>Multi-Camera <span class="mw-lingo-term" data-lingo-term-id="a6e8f9aed2ac6481dc25a18a33342d03">Rendering</span> will not function if the Cameras have different light masks. The cameras will be rendered one pass at a time in that case.
</p><p>This feature is used by the <a href="Render_TOP.html" title="Render TOP">Render TOP</a> when multiple cameras are listed in the 'Cameras' parameter. The 'Multi-Camera Hint' parameter can help control how this feature is used for that particular Render <span class="mw-lingo-term" data-lingo-term-id="6705777b712ee811e76fb07162081d63">TOP</span>. The results of each camera's render can be obtained using <a href="Render_Select_TOP.html" title="Render Select TOP">Render Select TOP</a>.
</p><p>Nvidia calls this feature 'Simultaneous Multi-Projection'.
</p><p>The multi-camera functionality on these GPUs is not general and requires some tricks to function properly. Because of this it's important all of your shaders make use of the TD* functions such as TDWorldToProj(), TDInstanceID() instead of doing those things manually and using built-in GLSL functionality. Functions such as TDFog() also require a camera index to be passed to it to apply fog for the correct camera.
</p>
<h2><span class="mw-headline" id="Image_Outputs">Image Outputs</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=39" title="Edit section: Image Outputs">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In the <a href="Render_TOP.html#Parameters_-_Images_Page" title="Render TOP">Render TOP</a> you can allocate extra image outputs that can be accessed during rendering. These outputs are arbitrarily sized images that can be written and read from at any location (similar to the Compute shader workflow for the GLSL <span class="mw-lingo-term" data-lingo-term-id="6705777b712ee811e76fb07162081d63">TOP</span>), using <code>imageStore()</code> and <code>imageLoad()</code>. The images will automatically be declared for you inside of the shader, you should not declare them yourself (as you do for other uniforms). This is because there is a lot of extra decoration required for the image uniforms. Currently when compiling in the GLSL <span class="mw-lingo-term" data-lingo-term-id="f0c2c0ca864067cc6e21a7ea2c1b1fdd">MAT</span> itself your code will result in an error, since the images are not available there. However when you apply your <span class="mw-lingo-term" data-lingo-term-id="f0c2c0ca864067cc6e21a7ea2c1b1fdd">MAT</span> to a geometry and render it via the Render <span class="mw-lingo-term" data-lingo-term-id="6705777b712ee811e76fb07162081d63">TOP</span>, a new version of your shader will be included that has that image declared.
</p><p>If you set the array size to 0, then the image will not be allocated as an array, so it should not have [] included in it's access. E.g an image named sTestOutput would be written to via:
</p>
<pre> imageStore(sTestOutput, ivec2(0, 0), vec4(0.0));
</pre>
<p>If the array size is 1 or more, then instead you'd use []:
</p>
<pre> imageStore(sTestOutput[0], ivec2(0, 0), vec4(0.0));
 
</pre>
<h2><span class="mw-headline" id="Outputting_gl_Position">Outputting gl_Position</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=40" title="Edit section: Outputting gl Position">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Although in general you can transform your points/vectors using the built-in model/view and projection matrices at will, when outputting to gl_Position you should use the built-in functions. These functions allow TouchDesigner to do some manipulation of the values for final output, depending on the rendering setup. For example for doing optimized <a href="#Multi-Camera_Rendering">Multi-Camera Rendering</a>, the position will need to be multiplied by the correct camera for this execution of the vertex shader. To give TouchDesigner a chance to do this manipulation, you should call the built-in functions to transform your vertex position:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">TDWorldToProj</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDWorldToProj</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>So for example at the end of your shader you would do:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TDWorldToProj</span><span class="p">(</span><span class="n">worldSpacePosition</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Specilization_Constants">Specilization Constants</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=41" title="Edit section: Specilization Constants">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Specialization Constants are a new feature in Vulkan that allow code to be re-optimized based on integer constant values, without doing a full recompilation of the shader code. These are useful to set the value for rarely changing values such as 'modes' in shader, or selection of particular code paths that are doing via a switch() or if() statement. In the past this may have been done with a <code>#define</code> statement, or a <code>uniform</code>.
A specialized version of a shader will be cached and re-used, but takes up <span class="mw-lingo-term" data-lingo-term-id="52f9ec21735243ad9917cda3ca077d32">GPU</span> resources. So they should not be used for constantly changing values, but instead for values that are only changed sometimes, within a limited range of values.
</p><p>To define a specialization constant, declare a constant with an extra layout() qualifier.
</p>
<pre> layout(constant_id = 0) const int SomeMode = 0;
</pre>
<p>Then you can use <code>SomeMode</code> just as you would any other variable. If you don't want it to be = 0, you can assign a different value on the 'Constants' page of the <a href="GLSL_TOP.html" title="GLSL TOP">GLSL TOP</a>, <a href="GLSL_MAT.html" title="GLSL MAT">GLSL MAT</a> etc.
You can declare multiple specialization constants, you just need to give each one it's own unique <code>constant_id</code> value (0, 1, 2, etc.).
</p>
<h2><span class="mw-headline" id="Working_with_Deforms">Working with Deforms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=42" title="Edit section: Working with Deforms">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Currently there are two different types deformations that can be applied to geometry: <a href="Deforming_Geometry_(Skinning).html" title="Deforming Geometry (Skinning)"> skinned deforms</a> and instanced transforms.
</p><p>TouchDesigner automatically encapsulates all of the work for both of these deforms in the GLSL functions.
Use the *Vec version when deforming vectors.<br><b>These functions always return the point/vector in World space, not model/<span class="mw-lingo-term" data-lingo-term-id="28a7e2d07553a70b039bb585895e0bf0">SOP</span>.</b>
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">TDDeform</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDDeform</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDDeformVec</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDDeformNorm</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p><br>
As the shader writer, it's your job to manipulate the vertex attributes such as the position and normal (since there's no place for TouchDesigner to do it if you're the one writing the shader), so it's up to you to call the TDDeform() function. In general you will simply call it simply like this:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">worldSpaceVert</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TDDeform</span><span class="p">(</span><span class="kt">vec4</span><span class="p">(</span><span class="n">TDPos</span><span class="p">(),</span><span class="w"> </span><span class="mf">1.0</span><span class="p">));</span><span class="w"> </span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpaceNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TDDeformNorm</span><span class="p">(</span><span class="n">TDNormal</span><span class="p">()));</span><span class="w"></span>
</pre></div>
<p>However you can use the below declared functions directly.
</p>
<h3><span id="Skinning_Deforms_.28Bone_Deforms.29"></span><span class="mw-headline" id="Skinning_Deforms_(Bone_Deforms)">Skinning Deforms (Bone Deforms)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=43" title="Edit section: Skinning Deforms (Bone Deforms)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>When you enable the Deform feature in the GLSL <span class="mw-lingo-term" data-lingo-term-id="f0c2c0ca864067cc6e21a7ea2c1b1fdd">MAT</span>, TouchDesigner will automatically declare some attributes, varyings, uniforms and functions for you to use to deform your geometry in the same way that other MATs deform geometry. It's important you don't re-use any of these reserved words when using deforms to avoid name conflicts when compiling the shader. Even when not using deforms though, the below listed functions will be declared anyway so shader code will run correctly both when deforms are turned on and off. The functions do nothing when deforms are off (and have no cost to the shader speed). The bone matrices for deforms are built by using the pCaptPath and pCaptData detail attributes along with the the bone's current position based on the skeleton at that frame. In SOPs the 'pCapt' attribute holds pairs of indices/weights for each bone affecting the vertex. In POPs these are instead loaded into two attributes called 'BoneIndices' and 'BoneWeights'. More information on how Skinning Deforms work can be found here:
<a href="Deforming_Geometry_(Skinning).html" title="Deforming Geometry (Skinning)">Deforming Geometry (Skinning)</a>
</p>
<h4><span class="mw-headline" id="Functions">Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=44" title="Edit section: Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>You generally will not need to call these directly, they are called by the <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">TDDeform</span><span class="p">()</span><span class="w"></span></code> function.
</p><p>In the vertex shader:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">TDSkinnedDeform</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDSkinnedDeformVec</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">vec</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>You can get the bone matrix for the given matrix index with this function:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">mat4</span><span class="w"> </span><span class="n">TDBoneMat</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">boneIndex</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h3><span class="mw-headline" id="Instancing">Instancing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=45" title="Edit section: Instancing">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>When you enable instancing on the <span class="mw-lingo-term" data-lingo-term-id="d9a17c1c9e8ef6866e4dbeef41c741b2">Instance</span> page of the <a href="Geometry_COMP.html" title="Geometry COMP">Geometry COMP</a> the TDDeform() functions will automatically call the correct lower level function that will transform the instance, based on the channels given in the XForm <span class="mw-lingo-term" data-lingo-term-id="8b9d2cce2836537aabe6f2e0dd5da293">CHOP</span> parameter. If you don't specify a <span class="mw-lingo-term" data-lingo-term-id="8b9d2cce2836537aabe6f2e0dd5da293">CHOP</span>, then all of the instances will be drawn at the same spot, unless you transform them yourself. 
</p>
<h4><span id="Instance_Index.2FID"></span><span class="mw-headline" id="Instance_Index/ID"><span class="mw-lingo-term" data-lingo-term-id="d9a17c1c9e8ef6866e4dbeef41c741b2">Instance</span> Index/ID</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=46" title="Edit section: Instance Index/ID">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>To calculate the instance ID, use the provided TDInstanceID() function. Do not use gl_InstanceID directly because the number of instances being rendered may be larger than requested due to <a href="#Multi-Camera_Rendering">Multi-Camera Rendering</a>.
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">TDInstanceID</span><span class="p">();</span><span class="w"></span>
</pre></div>
<p>Since this function is only available in the vertex shader, you will need to pass it onwards to the pixel shader through an out/in, if you require it in the pixel shader.
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// In the vertex shader, declare something like this, and assign vInstanceID = TDInstanceID() in the main()</span><span class="w"></span>
<span class="k">flat</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vInstanceID</span><span class="p">;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">vInstanceID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TDInstanceID</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="c1">// other main vertex function stuff</span><span class="w"></span>
<span class="w">	</span><span class="c1">// ....</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And in the pixel shader you can read this value if it's declared like this:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Pixel shader</span><span class="w"></span>
<span class="k">flat</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vInstanceID</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>This is declared as <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="k">flat</span><span class="w"></span></code> since <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="kt">int</span><span class="w"></span></code> variable types can not be interpolated across a primitive.
</p>
<h4><span class="mw-headline" id="Deform_Functions">Deform Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=47" title="Edit section: Deform Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>You generally will not need to call any of these directly, they are called by the TDDeform() function. These functions are only available in the vertex shader.
</p><p>In the vertex shader:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceDeform</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDInstanceDeformVec</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">vec</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>For the transform, access these matrices using the functions:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">mat4</span><span class="w"> </span><span class="n">TDInstanceMat</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceIndex</span><span class="p">);</span><span class="w"></span>
<span class="kt">mat4</span><span class="w"> </span><span class="n">TDInstanceMat</span><span class="p">();</span><span class="w"></span>
</pre></div>
<p>These matrices will contain the entire transform, including TX, TY, TZ, SX, SY, SZ as well as Rotate To.
</p>
<h4><span class="mw-headline" id="Attribute_Functions">Attribute Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=48" title="Edit section: Attribute Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>When modifying the texture coordinates, these functions do the texture coordinate modifications per instance. t is the texture coordinate to modify. The version without instanceIndex will use the current value for gl_InstanceID automatically.
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">vec3</span><span class="w"> </span><span class="n">TDInstanceTexCoord</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">TDInstanceTexCoord</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>To modify diffuse color, these functions will replace/add/subtract from the original diffuse color. In general you'll want to pass in the result of TDPointColor() into these functions to have them modify it. If instance color is not in use, this function will just return the passed in color, unmodified. 
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceColor</span><span class="p">(</span><span class="kt">vec4</span><span class="w"> </span><span class="n">curColor</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceColor</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">curColor</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Custom instance attributes can be retrieved using these functions:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceCustomAttrib0</span><span class="p">();</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceCustomAttrib0</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceIndex</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceCustomAttrib1</span><span class="p">();</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceCustomAttrib1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceIndex</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceCustomAttrib2</span><span class="p">();</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceCustomAttrib2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceIndex</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceCustomAttrib3</span><span class="p">();</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceCustomAttrib3</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceIndex</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h4><span class="mw-headline" id="Instance_Texturing"><span class="mw-lingo-term" data-lingo-term-id="d9a17c1c9e8ef6866e4dbeef41c741b2">Instance</span> Texturing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=49" title="Edit section: Instance Texturing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p><span class="mw-lingo-term" data-lingo-term-id="d9a17c1c9e8ef6866e4dbeef41c741b2">Instance</span> texturing allows mapping larger number of individual textures onto instances. The number of textures available to be used in a single render varies by <span class="mw-lingo-term" data-lingo-term-id="52f9ec21735243ad9917cda3ca077d32">GPU</span>. The resolution/pixel format of each texture can be different. It avoids needing to use a 2D Texture Array to map multiple images onto instances. Only one type of texture dimension is supported at a time (2D, Cube etc). Access the textures is a two step process. First you need to get the texture index for the current instance you are outputting. This is achieved through <code>TDInstanceTextureIndex()</code>. Then you can use that texture index in a call to <code>TDInstanceTexture()</code> to obtain the sampled texture color at the passed coordinates. There are a few variations of these functions. In the vertex shader there are versions that can implicitly know the current instance index and output using that. In both vertex/pixel shaders there is also versions that allow you to manually specify the instance index via a parameter. You will typically be sampling the texture in the pixel shader, in which case you want to obtain the texture index in the vertex shader, then pass it through to the pixel shader via a <code>flat uint</code> in/out variable.
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// AVAILABLE IN THE VERTEX SHADER ONLY</span><span class="w"></span>
<span class="c1">// Implicitly uses the current instance. Returns the texture index for this instance.</span><span class="w"></span>
<span class="kt">uint</span><span class="w"> </span><span class="n">TDInstanceTextureIndex</span><span class="p">();</span><span class="w"></span>
<span class="c1">// Returns the texture color at the given 'uv', implicitly using the current instance index to determine which texture to sample.</span><span class="w"></span>
<span class="c1">// You will not usually be using these versions of TDInstanceTexture(), since they are only available in the vertex shader.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceTexture</span><span class="p">(</span><span class="kt">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceTexture</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">uv</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>If you require more custom control of which instance texture you which to use, you can use these functions instead:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// AVAILABLE IN ALL SHADER STAAGES</span><span class="w"></span>
<span class="c1">// Gives to you the textureIndex for the given instanceIndex.</span><span class="w"></span>
<span class="kt">uint</span><span class="w"> </span><span class="n">TDInstanceTextureIndex</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">instanceIndex</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Samples the texture 'texIndex' at the given 'uv'.</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceTexture</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="n">texIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">uv</span><span class="p">);</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">TDInstanceTexture</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="n">texIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>The best way to see this code being used in a live example is to output a shader from the Phong <span class="mw-lingo-term" data-lingo-term-id="f0c2c0ca864067cc6e21a7ea2c1b1fdd">MAT</span> that is doing instance texturing.
</p>
<h2><span class="mw-headline" id="Point_Sprites"><span class="mw-lingo-term" data-lingo-term-id="2a3cd5946cfd317eb99c3d32e35e2d4c">Point</span> Sprites</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=50" title="Edit section: Point Sprites">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><span class="mw-lingo-term" data-lingo-term-id="2a3cd5946cfd317eb99c3d32e35e2d4c">Point</span> Sprites must now use <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="kt">vec2</span><span class="w"> </span><span class="n">TDPointCoord</span><span class="p">()</span><span class="w"></span></code> instead of <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="nb">gl_PointCoord</span><span class="w"></span></code> to obtain the texture coordinates for the sprite. Using gl_PointCoord will result in the texture coordinates being flipped vertically in some cases.
</p><p>When rendering point sprites primitives you are required to write to the vertex shader output <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="nb">gl_PointSize</span><span class="w"></span></code>. This output variable determines how large the point sprite is (in pixels) when it is rendered. If you don't write to the output then your point sizes are undefined. 
</p><p>Each point sprite will be rendered as a square of pixels <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="nb">gl_PointSize</span><span class="w"></span></code> pixels wide. The square of pixels will receive textures coordinates from 0-1 over the entire square in the pixel shader, obtained via <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">TDPointCoord</span><span class="p">()</span><span class="w"></span></code>.
</p>
<h2><span class="mw-headline" id="Order_Independent_Transparency">Order Independent Transparency</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=51" title="Edit section: Order Independent Transparency">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>You can make your shader support Order Independent Transparency by simply adding this line at the start of your pixel shader's main() function. If Order Independent Transparency isn't enabled in the Render <span class="mw-lingo-term" data-lingo-term-id="6705777b712ee811e76fb07162081d63">TOP</span>, then this function will do nothing. 
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="n">TDCheckOrderIndTrans</span><span class="p">();</span><span class="w"></span>
</pre></div>
<h2><span class="mw-headline" id="Dithering">Dithering</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=52" title="Edit section: Dithering">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>If dithering is enabled in the <a href="Render_TOP.html" title="Render TOP">Render TOP</a>, you can have this dithering applied to your color by simply calling:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="n">finalColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TDDither</span><span class="p">(</span><span class="n">finalColor</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>You generally want to do this right at the end of the shader, just before you write the value to your output color. If dithering is disabled in the Render <span class="mw-lingo-term" data-lingo-term-id="6705777b712ee811e76fb07162081d63">TOP</span> this function will still be available (to avoid compiler errors), but it will leave the color unchanged.
</p>
<h2><span class="mw-headline" id="Picking">Picking</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=53" title="Edit section: Picking">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The Render Pick <span class="mw-lingo-term" data-lingo-term-id="cc2bcf28d9ffc17fcbf169f3325607bb">DAT</span> and <span class="mw-lingo-term" data-lingo-term-id="8b9d2cce2836537aabe6f2e0dd5da293">CHOP</span> do their work with a render operation, so they need to interact with the shader to do their work. If you export a Phong <span class="mw-lingo-term" data-lingo-term-id="f0c2c0ca864067cc6e21a7ea2c1b1fdd">MAT</span> shader you will see the following lines in it
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#ifndef TD_PICKING_ACTIVE</span><span class="w"></span>
<span class="w">	</span><span class="c1">// All the typical shader code</span><span class="w"></span>
<span class="cp">#else</span><span class="w"></span>
<span class="w">	</span><span class="n">TDWritePickingValues</span><span class="p">();</span><span class="w"></span>
<span class="cp">#endif</span><span class="w"></span>
</pre></div>
<p>The key thing that is occurring here is that when picking is occuring, the define TD_PICKING_ACTIVE is set and only the code inside the #else block is executed. The function:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">TDWritePickingValues</span><span class="p">();</span><span class="w"></span>
</pre></div>
<p>Will write default values for picking, which the Render Pick <span class="mw-lingo-term" data-lingo-term-id="cc2bcf28d9ffc17fcbf169f3325607bb">DAT</span>/<span class="mw-lingo-term" data-lingo-term-id="8b9d2cce2836537aabe6f2e0dd5da293">CHOP</span> will read. If you have a custom shader that changes vertex positions in a non standard way, or if you want to output different kinds of information (like a color other than TDPointColor()), you can replace the values that have been written by this function afterwards. The values available to you are:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="n">TDPickVertex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">sopSpacePosition</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpacePosition</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">camSpacePosition</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">sopSpaceNormal</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldSpaceNormal</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">camSpaceNormal</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec3</span><span class="w"> </span><span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="k">flat</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">instanceId</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">vec4</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">vTDPickVert</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>So for example if you modifying the vertex position in a way different from the standard TDDeform() way, you could write these newly calculated values to like this:
<b> Be sure to do this AFTER the call to TDWritePickingValues(), otherwise that call will overwrite your values </b>.
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="n">TDWritePickingValues</span><span class="p">();</span><span class="w"></span>
<span class="n">vTDPickVert</span><span class="p">.</span><span class="n">sopSpacePosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newPosition</span><span class="p">;</span><span class="w"></span>
<span class="n">vTDPickVert</span><span class="p">.</span><span class="n">worldSpacePosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uTDMats</span><span class="p">[</span><span class="n">TDCameraIndex</span><span class="p">()].</span><span class="n">world</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">newPosition</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w"></span>
<span class="n">vTDPickVert</span><span class="p">.</span><span class="n">camSpacePosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uTDMats</span><span class="p">[</span><span class="n">TDCameraIndex</span><span class="p">()].</span><span class="n">worldCam</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">newPosition</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>You do not have to write to all the entries in this structure, but you can for completeness. Only the values that are being read by the Render Pick <span class="mw-lingo-term" data-lingo-term-id="8b9d2cce2836537aabe6f2e0dd5da293">CHOP</span>/<span class="mw-lingo-term" data-lingo-term-id="cc2bcf28d9ffc17fcbf169f3325607bb">DAT</span> (selected in their parameters) must be filled in.
</p><p>For custom attributes that you set for picking in the <a href="Render_Pick_CHOP.html" title="Render Pick CHOP">Render Pick CHOP</a> or <a href="Render_Pick_DAT.html" title="Render Pick DAT">Render Pick DAT</a>, the attributes are available in <code>vTDCustomPickVert</code> with the name and size as defined in the Render Pick node.
</p>
<h2><span class="mw-headline" id="Shadertoy">Shadertoy</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=54" title="Edit section: Shadertoy">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="VR_Shaders">VR Shaders</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=55" title="Edit section: VR Shaders">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Shaders that come from <a rel="nofollow" class="external text" href="http://www.shadertoy.com/">Shadertoy</a> that support VR rendering will have a <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">mainVR</span><span class="w"></span></code> function defined. Re-creating the <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">fragRayOri</span><span class="w"></span></code> and <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">fragRayDir</span><span class="w"></span></code> variables that function uses inside of TD is simple. In the vertex shader:
</p>
<div class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">worldSpaceVert</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TDDeform</span><span class="p">(</span><span class="n">TDPos</span><span class="p">());</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">worldSpaceCamPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uTDMat</span><span class="p">.</span><span class="n">camInverse</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"> </span><span class="c1">// The last column of the camera transform is it's position</span><span class="w"></span>

<span class="kt">vec3</span><span class="w"> </span><span class="n">fragRayOri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worldSpaceCamPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">fragRayDir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worldSpaceVert</span><span class="p">.</span><span class="n">xyz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">worldSpaceCamPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Pass these variables to the pixel shader using 'out' variables named of your choosing</span><span class="w"></span>
</pre></div>
<p>And in the pixel shader you just need to normalize whatever variable the <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">fragRayDir</span><span class="w"></span></code> was went through. The variable that came from <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">fragRayOri</span><span class="w"></span></code> and be used as-is.
</p><p>To support these shaders, which are usually raymarching shaders, you'll want to render geometry that covers the entire viewport, such as putting a sphere around your camera.
</p>
<h2><span class="mw-headline" id="Other_Notes">Other Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=56" title="Edit section: Other Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span id=".23version_statement"></span><span class="mw-headline" id="#version_statement">#version statement</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=57" title="Edit section: #version statement">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The #version statement will be added to the code automatically for you. Your code should not have a #version statement, otherwise compile errors may occur.
</p>
<h3><span id=".23include_statements"></span><span class="mw-headline" id="#include_statements">#include statements</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=58" title="Edit section: #include statements">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>You can use an #include statement in one <span class="mw-lingo-term" data-lingo-term-id="cc2bcf28d9ffc17fcbf169f3325607bb">DAT</span> to include code from another <span class="mw-lingo-term" data-lingo-term-id="cc2bcf28d9ffc17fcbf169f3325607bb">DAT</span>. The path can be absolute or relative.
</p>
<pre> #include &lt;/project1/text1&gt;
 #include &lt;../../geo1/text2&gt;
 #include "text2"
</pre>
<h3><span class="mw-headline" id="Diagnosing_crashes_due_to_GLSL">Diagnosing crashes due to GLSL</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=59" title="Edit section: Diagnosing crashes due to GLSL">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If you are experiencing a full application crash when writing GLSL code, you may want to refer to <a href="Debugging_crashes_triggered_by_GLSL_errors.html" title="Debugging crashes triggered by GLSL errors">this article</a> for tips on diagnosing these issues.
</p>
<h3><span class="mw-headline" id="Changes_from_GLSL_1.20">Changes from GLSL 1.20</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=60" title="Edit section: Changes from GLSL 1.20">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Shaders written for 1.20 will not compile as 3.30 shaders. The language received a large overhaul, changing the name of many key functions and replacing a lot of functionality. All of the changes can be seen in the official GLSL documentation linked to earlier. Some of the more important changes are:
</p>
<ul><li>Removed <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">texture1D</span><span class="p">(</span><span class="kt">sampler1D</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">texture2D</span><span class="p">(</span><span class="kt">sampler2D</span><span class="p">,</span><span class="w"> </span><span class="kt">vec2</span><span class="p">),</span><span class="w"> </span><span class="n">etc</span><span class="p">.</span><span class="w"></span></code> All texture sampling is done with identical function names, regardless of the dimensionality of the texture. e.g. <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">texture</span><span class="p">(</span><span class="kt">sampler1D</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">texture</span><span class="p">(</span><span class="kt">sampler2D</span><span class="p">,</span><span class="w"> </span><span class="kt">vec2</span><span class="p">)</span><span class="w"></span></code>.</li></ul><ul><li>Removed the keyword <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="k">varying</span><span class="w"></span></code>. Instead use <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="k">in</span><span class="w"></span></code> and <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="k">out</span><span class="w"></span></code> (depending on if the value is getting outputted from the shader or inputted from a previous shader stage). Examples later on in the article.</li></ul><ul><li>Removed the keyword <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="k">attribute</span><span class="w"></span></code>. Instead just use <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="k">in</span><span class="w"></span></code> in your vertex shader.</li></ul><ul><li>Removed built-in varyings <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="nb">gl_TexCoord</span><span class="p">[]</span><span class="w"></span></code>. You'll need to always declare your own variables that get output/input between shader stages.</li></ul><ul><li>Removed <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="nb">gl_FragColor</span><span class="w"></span></code> and <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="nb">gl_FragData</span><span class="p">[]</span><span class="w"></span></code>. Instead you name your own color outputs using the syntax <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">oFragColor</span><span class="p">[</span><span class="n">TD_NUM_COLOR_BUFFERS</span><span class="p">]</span><span class="w"></span></code>.</li></ul><ul><li>Removed all built-in attributes such as <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="nb">gl_<span class="mw-lingo-term" data-lingo-term-id="b22b929ba52471a02d18bb3a4e4472e6">Vertex</span></span><span class="p">,</span><span class="w"> </span><span class="nb">gl_MultiTexCoord0</span><span class="p">,</span><span class="w"> </span><span class="nb">gl_Normal</span><span class="w"></span></code>. In TouchDesigner these attributes will be accessible through automatically declared attributes such as <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">TDPos</span><span class="p">();</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">TDTexCoord</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="n">coordLayer</span><span class="p">);</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">TDNormal</span><span class="p">();</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">TDPointColor</span><span class="p">()</span><span class="w"></span></code>. More details on this <a href="#Working_with_Geometry_Attributes">later</a>.</li></ul><ul><li>Removed almost all built-in uniforms such as matrices (<code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="nb">gl_ModelViewMatrix</span><span class="p">,</span><span class="w"> </span><span class="nb">gl_ProjectionMatrix</span><span class="w"></span></code>), light information (<code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="nb">gl_LightSource</span><span class="p">[]</span><span class="w"></span></code>), fog information (<code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="nb">gl_Fog</span><span class="w"></span></code>). All of this data will be available through new means provided by TouchDesigner, detailed <a href="#TouchDesigner_specific_Uniforms">later</a>.</li></ul><ul><li>Arrays of samplers are now supported, and are used extensively in TouchDesigner when appropriate. There are limitations on how these samplers are indexed though, detailed in the GLSL spec for the particular version you are using (3.30 has different rules from 4.10, for example).</li></ul><h3><span class="mw-headline" id="Major_changes_since_TouchDesigner088">Major changes since TouchDesigner088</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=61" title="Edit section: Major changes since TouchDesigner088">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A lot of changes have been done to TouchDesigner's GLSL API in 099. Most of these changes were done to better facilitate <a href="#Multi-Camera_Rendering">Multi-Camera Rendering</a>. A summary of most of these changes is:
</p>
<ul><li>Lighting and other work is now done in World space instead of Camera space. This makes code cleaner since the shaders would need to do their work in multiple different camera spaces for multiple cameras. Legacy GLSL shaders are supported with the <a href="GLSL_TOP.html" title="GLSL TOP">GLSL TOPs</a> 'Lighting Space' parameter which will be set to Camera Space for older shaders.</li>
<li><code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">TDInstanceID</span><span class="p">()</span><span class="w"></span></code> should be used instead of <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="nb">gl_InstanceID</span><span class="o">/</span><span class="n">uTDInstanceIDOffset</span><span class="w"></span></code>.</li>
<li><code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">uTDMat</span><span class="w"></span></code> has been removed when lighting in World Space, use the array <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">uTDMats</span><span class="p">[]</span><span class="w"></span></code> instead.</li>
<li>Some values from the <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">uTDGeneral</span><span class="w"></span></code> structure have been moved to <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">uTDCamInfos</span><span class="p">[]</span><span class="w"></span></code>, since that info is camera specific.</li>
<li>A notion of camera index (obtained in the vertex shader using <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">TDCameraIndex</span><span class="p">()</span><span class="w"></span></code>), is needed for some functions such as <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">TDFog</span><span class="p">()</span><span class="w"></span></code>.</li>
<li><code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="n">TDAlphaTest</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"></span></code> must be called to apply the alpha test. It can be safely called when the alpha test is disabled on the <span class="mw-lingo-term" data-lingo-term-id="f0c2c0ca864067cc6e21a7ea2c1b1fdd">MAT</span>, it'll do nothing in that case.</li>
<li>Before writing any color to a output color buffer, it should be passed through <code class="mw-highlight mw-highlight-lang-glsl mw-content-ltr" dir="ltr"><span class="kt">vec4</span><span class="w"> </span><span class="n">TDOutputSwizzle</span><span class="p">(</span><span class="kt">vec4</span><span class="p">)</span><span class="w"></span></code>. This ensures the channels are in the correct place depending on how the channels are stored in the output texture. For example Alpha-only textures may be stored in a 'Red-only' texture internally, so the alpha value will need to be swizzled over to the red channel before output.</li></ul><h2><span class="mw-headline" id="Related_Articles">Related Articles</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit&amp;section=62" title="Edit section: Related Articles">edit</a><span class="mw-editsection-bracket">]</span></span></h2></div><div class="mw-lingo-tooltip" id="d92a8333dd3ccb895cc65f7455b71206"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>MATs or Materials are an <a href="Operator_Family.html" title="Operator Family">Operator Family</a> that applies a <a href="Shader.html" title="Shader">Shader</a> to a SOP or 3D Geometry Object for rendering textured surfaces with lighting.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="b22b929ba52471a02d18bb3a4e4472e6"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>A sequence of vertices form a <a href="Polygon.html" title="Polygon">Polygon</a> in a <a href="SOP.html" title="SOP">SOP</a>. Each vertex is an integer index into the <a href="Point_List.html" title="Point List">Point List</a>, and each <a href="Point.html" title="Point">Point</a> holds an XYZ position and attributes like Normals and Texture Coordinates.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="a88a92f4a0e793589f2341851a15c660"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>The OpenGL (pre-2022) or Vulkan (2022-) code that runs on the GPU and creates rendered images from polygons and textures. A shader is programmed in <a href="Text_DAT.html" title="Text DAT">Text DATs</a> and referenced by a <a href="GLSL_MAT.html" title="GLSL MAT">GLSL Material</a> or a <a href="GLSL_TOP.html" title="GLSL TOP">GLSL TOP</a>. Shaders are composed of up to three parts: Vertex Shader, Pixel Shader and Compute Shader.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="28a7e2d07553a70b039bb585895e0bf0"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>A <a href="Operator_Family.html" title="Operator Family">Operator Family</a> that reads, creates and modifies 3D points, polygons, lines, particles, surfaces, spheres and meatballs. Particles and point clouds are now done primarily on the GPU using TOPs.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="287234a1ff35a314b5b6bc4e5828e745"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>Information associated with <a href="SOP.html" title="SOP">SOP</a> geometry. <a href="Point.html" title="Point">Points</a> and <a href="Primitive.html" title="Primitive">primitives</a> (polygons, NURBS, etc.) can have any number of attributes - position (P) is standard, and built-in optional attributes are <a href="Normals.html" title="Normals">normals</a> (N), texture coordinates (uv), color (Cd), etc.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="f0c2c0ca864067cc6e21a7ea2c1b1fdd"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>MATs or Materials are an <a href="Operator_Family.html" title="Operator Family">Operator Family</a> that applies a <a href="Shader.html" title="Shader">Shader</a> to a SOP or 3D Geometry Object for rendering textured surfaces with lighting.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="85a1cdddc59cb89e6297acc2f2fc1755"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>An <a href="Operator_Family.html" title="Operator Family">Operator Family</a> that contains its own <a href="Network.html" title="Network">Network</a>. There are sixteen 3D <a href="Object_Component.html" title="Object Component">Object Component</a> and ten 2D <a href="Panel_Component.html" title="Panel Component">Panel Component</a> types. See also <a href="Network_Path.html" title="Network Path">Network Path</a>.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="6705777b712ee811e76fb07162081d63"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>An <a href="Operator_Family.html" title="Operator Family">Operator Family</a> that creates, composites and modifies images, and reads/writes images and movies to/from files and the network. TOPs run on the graphics card's GPU.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="f38ba60f185531947a20345d16feda13"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>Quad Reprojection renders pixel-perfect perspective-correct images for flat TVs and LED panels hung at any orientation.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="a6e8f9aed2ac6481dc25a18a33342d03"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>Rendering is the creation of a 3D image with the Render TOP. Rendering is also used more generally to include the compositing (with TOPs) to generate an output image.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="d9a17c1c9e8ef6866e4dbeef41c741b2"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>(1) A <a href="Geometry_COMP.html" title="Geometry COMP">Geometry Component</a> can instance and render its SOP geometry many times: once for each sample in a CHOP, row of a DAT table, pixel in a TOP, or point of a SOP, (2) An instance is an OP that doesn't actually have its own data, but rather just refers to an OP (or has an input) whose data it uses. This includes Null OPs, Switch OPs and in some cases Select OPs.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="5213871d0c036a1f78c3c79db51d40d6"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>A technique or workflow that allows for displaying content on often irregular shapes and surfaces.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="52f9ec21735243ad9917cda3ca077d32"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>The Graphics Processing Unit. This is the high-speed, many-core processor of the graphics card/chip that takes geometry, images and data from the CPU and creates images and processed data.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="8b9d2cce2836537aabe6f2e0dd5da293"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>An <a href="Operator_Family.html" title="Operator Family">Operator Family</a> which operate on <a href="Channel.html" title="Channel">Channels</a> (a sequence of numbers (<a href="Sample.html" title="Sample">Samples</a>)) which are used for animation, audio, mathematics, simulation, logic, UI construction, and data streamed from/to devices and protocols.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="2a3cd5946cfd317eb99c3d32e35e2d4c"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>Each SOP has a list of Points. Each point has an XYZ 3D position value plus other optional attributes. Each polygon <a href="Primitive.html" title="Primitive">Primitive</a> is defined by a vertex list, which is list of point numbers.
</p>
</div></div>
</div><div class="mw-lingo-tooltip" id="cc2bcf28d9ffc17fcbf169f3325607bb"><div class="mw-lingo-definition navigation-not-searchable"><div class="mw-lingo-definition-text">
<p>An <a href="Operator_Family.html" title="Operator Family">Operator Family</a> that manipulates text strings: multi-line text or tables. Multi-line text is often a python <a href="Script.html" title="Script">Script</a> or <a href="GLSL.html" title="GLSL">GLSL</a> Shader, but can be any multi-line text. <a href="Table_DAT.html" title="Table DAT">Tables</a> are rows and columns of cells, each containing a text string.
</p>
</div></div>
</div>
<!-- 
NewPP limit report
Cached time: 20250409035127
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.224 seconds
Real time usage: 0.236 seconds
Preprocessor visited node count: 945/1000000
Post‐expand include size: 2405/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 119371/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%   13.909      1 -total
 30.24%    4.206      1 Multi-Camera_Rendering
 21.02%    2.924      1 GLSL_Matrix_Functions
 15.39%    2.141      1 Specialization_Constants
-->

<!-- Saved in parser cache with key wiki:pcache:idhash:1484-0!canonical and timestamp 20250409035127 and revision id 33289.
 -->
</div>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;oldid=33289">https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;oldid=33289</a>"</div></div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Categories</a>: <ul><li><a href="Category_Touch_Glossary.html" title="Category:Touch Glossary">Touch Glossary</a></li><li><a href="Category_Rendering.html" title="Category:Rendering">Rendering</a></li><li><a href="Category_TDPages.html" title="Category:TDPages">TDPages</a></li><li><a href="Category_TouchDesigner_Tips.html" title="Category:TouchDesigner Tips">TouchDesigner Tips</a></li><li><a href="https://docs.derivative.ca/index.php?title=Category:Materials&amp;action=edit&amp;redlink=1" class="new" title="Category:Materials (page does not exist)">Materials</a></li><li><a href="Category_GLSL.html" title="Category:GLSL">GLSL</a></li><li><a href="https://docs.derivative.ca/index.php?title=Category:Programming_in_TouchDesigner&amp;action=edit&amp;redlink=1" class="new" title="Category:Programming in TouchDesigner (page does not exist)">Programming in TouchDesigner</a></li></ul></div></div>
	</div>
</div>

<div id="mw-navigation">
	<h2>Navigation menu</h2>
	<div id="mw-head">
		

<nav id="p-personal" class="vector-menu mw-portlet mw-portlet-personal vector-user-menu-legacy" aria-labelledby="p-personal-label" role="navigation"  >
	<h3
		id="p-personal-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Personal tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="pt-login" class="mw-list-item"><a href="https://docs.derivative.ca/index.php?title=Special:UserLogin&amp;returnto=Write+a+GLSL+Material" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o"><span>Log in</span></a></li></ul>
		
	</div>
</nav>

		<div id="left-navigation">
			

<nav id="p-namespaces" class="vector-menu mw-portlet mw-portlet-namespaces vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-namespaces-label" role="navigation"  >
	<h3
		id="p-namespaces-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Namespaces</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected mw-list-item"><a href="Write_a_GLSL_Material.html" title="View the content page [c]" accesskey="c"><span>Page</span></a></li><li id="ca-talk" class="new mw-list-item"><a href="https://docs.derivative.ca/index.php?title=Talk:Write_a_GLSL_Material&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t"><span>Discussion</span></a></li><li id="ca-Experimental" class="new mw-list-item"><a href="https://docs.derivative.ca/index.php?title=Experimental:Write_a_GLSL_Material&amp;action=edit&amp;redlink=1" title=" (page does not exist)"><span>Experimental</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation"  >
	<input type="checkbox"
		id="p-variants-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-variants"
		class="vector-menu-checkbox"
		aria-labelledby="p-variants-label"
	/>
	<label
		id="p-variants-label"
		 aria-label="Change language variant"
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Canadian English</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

		</div>
		<div id="right-navigation">
			

<nav id="p-views" class="vector-menu mw-portlet mw-portlet-views vector-menu-tabs vector-menu-tabs-legacy" aria-labelledby="p-views-label" role="navigation"  >
	<h3
		id="p-views-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Views</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="ca-view" class="selected mw-list-item"><a href="Write_a_GLSL_Material.html"><span>Read</span></a></li><li id="ca-viewsource" class="mw-list-item"><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e"><span>View source</span></a></li></ul>
		
	</div>
</nav>

			

<nav id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation"  title="More options" >
	<input type="checkbox"
		id="p-cactions-checkbox"
		role="button"
		aria-haspopup="true"
		data-event-name="ui.dropdown-p-cactions"
		class="vector-menu-checkbox"
		aria-labelledby="p-cactions-label"
	/>
	<label
		id="p-cactions-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">More</span>
	</label>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"></ul>
		
	</div>
</nav>

			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<div>
			<h3 >
				<label for="searchInput">Search</label>
			</h3>
		<form action="https://docs.derivative.ca/index.php" id="searchform"
			class="vector-search-box-form">
			<div id="simpleSearch"
				class="vector-search-box-inner"
				 data-search-loc="header-navigation">
				<input class="vector-search-box-input"
					 type="search" name="search" placeholder="Search Derivative" aria-label="Search Derivative" autocapitalize="sentences" title="Search Derivative [f]" accesskey="f" id="searchInput"
				>
				<input type="hidden" name="title" value="Special:Search">
				<input id="mw-searchButton"
					 class="searchButton mw-fallbackSearchButton" type="submit" name="fulltext" title="Search the pages for this text" value="Search">
				<input id="searchButton"
					 class="searchButton" type="submit" name="go" title="Go to a page with this exact name if it exists" value="Go">
			</div>
		</form>
	</div>
</div>

		</div>
	</div>
	

<div id="mw-panel">
	<div id="p-logo" role="banner">
		<a class="mw-wiki-logo" href="Main_Page.html"
			title="Visit the main page"></a>
	</div>
	

<nav id="p-TouchDesigner" class="vector-menu mw-portlet mw-portlet-TouchDesigner vector-menu-portal portal" aria-labelledby="p-TouchDesigner-label" role="navigation"  >
	<h3
		id="p-TouchDesigner-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">TouchDesigner</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-Main-Page" class="mw-list-item"><a href="Main_Page.html"><span>Main Page</span></a></li><li id="n-Categories" class="mw-list-item"><a href="Special_Categories.html"><span>Categories</span></a></li><li id="n-Learn-TouchDesigner" class="mw-list-item"><a href="Learn_TouchDesigner.html"><span>Learn TouchDesigner</span></a></li><li id="n-Tutorials" class="mw-list-item"><a href="Tutorials.html"><span>Tutorials</span></a></li><li id="n-Interoperability" class="mw-list-item"><a href="Interoperability.html"><span>Interoperability</span></a></li><li id="n-Glossary" class="mw-list-item"><a href="TouchDesigner_Glossary.html"><span>Glossary</span></a></li><li id="n-Operators" class="mw-list-item"><a href="Operator.html"><span>Operators</span></a></li><li id="n-Python" class="mw-list-item"><a href="Python.html"><span>Python</span></a></li><li id="n-Python-Class-Reference" class="mw-list-item"><a href="TouchDesigner_Python_Classes.html"><span>Python Class Reference</span></a></li><li id="n-Palette" class="mw-list-item"><a href="Category_Palette.html"><span>Palette</span></a></li><li id="n-FAQ" class="mw-list-item"><a href="Frequently_Asked_Questions.html"><span>FAQ</span></a></li><li id="n-Recent-Doc-Edits" class="mw-list-item"><a href="Special_RecentChanges.html"><span>Recent Doc Edits</span></a></li><li id="n-Release-Notes" class="mw-list-item"><a href="Release_Notes.html"><span>Release Notes</span></a></li></ul>
		
	</div>
</nav>

	

<nav id="p-Downloads" class="vector-menu mw-portlet mw-portlet-Downloads vector-menu-portal portal" aria-labelledby="p-Downloads-label" role="navigation"  >
	<h3
		id="p-Downloads-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Downloads</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="n-TouchDesigner" class="mw-list-item"><a href="https://www.derivative.ca/download" rel="nofollow"><span>TouchDesigner</span></a></li><li id="n-Shared-Examples" class="mw-list-item"><a href="http://www.derivative.ca/Forum/viewforum.php?f=22" rel="nofollow"><span>Shared Examples</span></a></li></ul>
		
	</div>
</nav>


<nav id="p-tb" class="vector-menu mw-portlet mw-portlet-tb vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation"  >
	<h3
		id="p-tb-label"
		
		class="vector-menu-heading "
	>
		<span class="vector-menu-heading-label">Tools</span>
	</h3>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list"><li id="t-whatlinkshere" class="mw-list-item"><a href="Special_WhatLinksHere/Write_a_GLSL_Material.html" title="A list of all wiki pages that link here [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="Special_RecentChangesLinked/Write_a_GLSL_Material.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-print" class="mw-list-item"><a href="javascript:print();" rel="alternate" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li><li id="t-permalink" class="mw-list-item"><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;oldid=33289" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=info" title="More information about this page"><span>Page information</span></a></li><li id="t-cargopagevalueslink" class="mw-list-item"><a href="https://docs.derivative.ca/index.php?title=Write_a_GLSL_Material&amp;action=pagevalues" rel="cargo-pagevalues"><span>Page values</span></a></li></ul>
		
	</div>
</nav>

	
</div>

</div>

<footer id="footer" class="mw-footer" role="contentinfo" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 8 April 2025, at 22:51.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="Derivative_Privacy_policy.html">Privacy policy</a></li>
	<li id="footer-places-about"><a href="Derivative_About.html">About Derivative</a></li>
	<li id="footer-places-disclaimer"><a href="Derivative_General_disclaimer.html">Disclaimers</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li>
</ul>

</footer>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.224","walltime":"0.236","ppvisitednodes":{"value":945,"limit":1000000},"postexpandincludesize":{"value":2405,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":3,"limit":100},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":119371,"limit":5000000},"timingprofile":["100.00%   13.909      1 -total"," 30.24%    4.206      1 Multi-Camera_Rendering"," 21.02%    2.924      1 GLSL_Matrix_Functions"," 15.39%    2.141      1 Specialization_Constants"]},"cachereport":{"timestamp":"20250409035127","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":146});});</script>
</body>
<!-- Cached 20250409065207 -->

<!-- Mirrored from docs.derivative.ca/Write_a_GLSL_Material by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 24 May 2025 00:55:08 GMT -->
</html>